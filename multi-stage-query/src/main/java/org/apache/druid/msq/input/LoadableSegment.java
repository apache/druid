/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.druid.msq.input;

import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import org.apache.druid.common.guava.FutureUtils;
import org.apache.druid.error.DruidException;
import org.apache.druid.msq.counters.ChannelCounters;
import org.apache.druid.query.SegmentDescriptor;
import org.apache.druid.segment.ReferenceCountedSegmentProvider;
import org.apache.druid.segment.Segment;
import org.apache.druid.segment.loading.AcquireSegmentAction;
import org.apache.druid.segment.loading.AcquireSegmentResult;
import org.apache.druid.timeline.DataSegment;
import org.joda.time.Interval;

import javax.annotation.Nullable;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;

/**
 * Pointer to some data that can be read as a {@link Segment}. These are contained by
 * {@link PhysicalInputSlice#getLoadableSegments()}, which are in turn generated by {@link InputSliceReader#attach}.
 *
 * These objects do not hold resources and do not have a lifecycle. They are just pointers to data that hasn't
 * been acquired yet. Once {@link #acquire()} is called, the lifecycle begins.
 */
public class LoadableSegment
{
  private final AtomicBoolean acquired = new AtomicBoolean(false);
  private final Supplier<ListenableFuture<DataSegment>> dataSegmentFutureSupplier;
  private final SegmentDescriptor descriptor;
  @Nullable
  private final ChannelCounters inputCounters;
  @Nullable
  private final String description;
  private final Supplier<AcquireSegmentAction> acquireSupplier;
  private final boolean likelyCached;

  /**
   * Constructor.
   *
   * @param dataSegmentFutureSupplier supplier to fetch the DataSegment; called lazily and memoized
   * @param descriptor                segment descriptor for querying
   * @param inputCounters             optional counters for tracking input
   * @param description               user-oriented description for error messages
   * @param acquireSupplier           supplier to acquire the actual segment
   * @param likelyCached              whether the segment is likely cached locally
   */
  public LoadableSegment(
      Supplier<ListenableFuture<DataSegment>> dataSegmentFutureSupplier,
      SegmentDescriptor descriptor,
      @Nullable ChannelCounters inputCounters,
      @Nullable String description,
      Supplier<AcquireSegmentAction> acquireSupplier,
      boolean likelyCached
  )
  {
    this.dataSegmentFutureSupplier = dataSegmentFutureSupplier;
    this.descriptor = descriptor;
    this.inputCounters = inputCounters;
    this.description = description;
    this.acquireSupplier = acquireSupplier;
    this.likelyCached = likelyCached;
  }

  /**
   * Returns a LoadableSegment wrapper around a Segment object, which is not a regular Druid segment, has
   * no associated {@link DataSegment}, and whose lifecycle is not managed by the {@link LoadableSegment} instance.
   * The {@link #dataSegmentFuture()} returns a failed future.
   *
   * @param segment         the segment to wrap
   * @param queryInterval   the query interval to use for filtering
   * @param description     user-oriented description for error messages
   * @param channelCounters counters for tracking input
   */
  public static LoadableSegment forSegment(
      final Segment segment,
      final Interval queryInterval,
      @Nullable final String description,
      @Nullable final ChannelCounters channelCounters
  )
  {
    final ListenableFuture<AcquireSegmentResult> segmentFuture =
        Futures.immediateFuture(AcquireSegmentResult.cached(ReferenceCountedSegmentProvider.of(segment)));
    final AcquireSegmentAction acquireSegmentAction = new AcquireSegmentAction(() -> segmentFuture, null);
    final ListenableFuture<DataSegment> dataSegmentFuture =
        Futures.immediateFailedFuture(DruidException.defensive("DataSegment not available"));
    return new LoadableSegment(
        () -> dataSegmentFuture,
        new SegmentDescriptor(queryInterval, "0", 0),
        channelCounters,
        description,
        () -> acquireSegmentAction,
        true
    );
  }

  /**
   * Returns a future for the {@link DataSegment} object. The future is created lazily when this method is first
   * called. For LoadableSegments created via {@link #forSegment}, this will return a failed future.
   */
  public ListenableFuture<DataSegment> dataSegmentFuture()
  {
    return dataSegmentFutureSupplier.get();
  }

  /**
   * Returns the {@link DataSegment} object, blocking until it is available. For LoadableSegments created via
   * {@link #forSegment}, this will throw an exception.
   */
  public DataSegment dataSegment()
  {
    return FutureUtils.getUnchecked(dataSegmentFuture(), false);
  }

  /**
   * Returns the descriptor that is used to query this segment. The interval of this descriptor is particularly
   * important: it acts as a filter on the underlying segment.
   */
  public SegmentDescriptor descriptor()
  {
    return descriptor;
  }

  /**
   * Returns input counters that should be updated as this segment is queried, or null if it is not necessary
   * to update input counters.
   */
  @Nullable
  public ChannelCounters inputCounters()
  {
    return inputCounters;
  }

  /**
   * User-oriented description, suitable for inclusion in log or error messages.
   */
  @Nullable
  public String description()
  {
    return description;
  }

  /**
   * Whether this segment is likely cached locally. Generally, this is set to true if the segment was cached locally
   * at the time we created the LoadableSegment object. Because the LoadableSegment object does not have a hold over
   * the segment, it is possible that the segment becomes uncached before {@link #acquire()} is called; hence the
   * "likely" rather than "definitely".
   */
  public boolean isLikelyCached()
  {
    return likelyCached;
  }

  /**
   * Acquire the actual segment. Non-blocking operation. Once this is called, callers are responsible for closing the
   * {@link AcquireSegmentAction}.
   */
  public AcquireSegmentAction acquire()
  {
    if (acquired.compareAndSet(false, true)) {
      return acquireSupplier.get();
    } else {
      throw DruidException.defensive("Segment with descriptor[%s] is already acquired", descriptor);
    }
  }
}
