/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.druid.msq.input;

import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import org.apache.druid.error.DruidException;
import org.apache.druid.msq.counters.ChannelCounters;
import org.apache.druid.query.SegmentDescriptor;
import org.apache.druid.segment.ReferenceCountedSegmentProvider;
import org.apache.druid.segment.Segment;
import org.apache.druid.segment.loading.AcquireSegmentAction;
import org.apache.druid.segment.loading.AcquireSegmentResult;

import javax.annotation.Nullable;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;

/**
 * Pointer to some data that can be read as a {@link Segment}. These are contained by
 * {@link PhysicalInputSlice#getLoadableSegments()}, which are in turn generated by {@link InputSliceReader#attach}.
 *
 * These objects do not hold resources and do not have a lifecycle. They are just pointers to data that hasn't
 * been acquired yet. Once {@link #acquire()} is called, the lifecycle begins.
 */
public class LoadableSegment
{
  private final AtomicBoolean acquired = new AtomicBoolean(false);
  private final SegmentDescriptor descriptor;
  @Nullable
  private final ChannelCounters inputCounters;
  @Nullable
  private final String description;
  private final Supplier<AcquireSegmentAction> acquireSupplier;
  private final boolean likelyCached;

  public LoadableSegment(
      SegmentDescriptor descriptor,
      @Nullable ChannelCounters inputCounters,
      @Nullable String description,
      Supplier<AcquireSegmentAction> acquireSupplier,
      boolean likelyCached
  )
  {
    this.descriptor = descriptor;
    this.inputCounters = inputCounters;
    this.description = description;
    this.acquireSupplier = acquireSupplier;
    this.likelyCached = likelyCached;
  }

  /**
   * Returns a LoadableSegment wrapper around a Segment object, whose lifecycle is not managed by this
   * {@link LoadableSegment} instance.
   */
  public static LoadableSegment forSegment(
      final SegmentDescriptor descriptor,
      @Nullable final ChannelCounters channelCounters,
      @Nullable final String description,
      final Segment segment
  )
  {
    final ListenableFuture<AcquireSegmentResult> segmentFuture =
        Futures.immediateFuture(AcquireSegmentResult.cached(ReferenceCountedSegmentProvider.of(segment)));
    final AcquireSegmentAction acquireSegmentAction = new AcquireSegmentAction(() -> segmentFuture, null);
    return new LoadableSegment(descriptor, channelCounters, description, () -> acquireSegmentAction, true);
  }

  /**
   * Returns the descriptor that is used to query this segment. The interval of this descriptor is particularly
   * important: it acts as a filter on the underlying segment.
   */
  public SegmentDescriptor descriptor()
  {
    return descriptor;
  }

  /**
   * Returns input counters that should be updated as this segment is queried, or null if it is not necessary
   * to update input counters.
   */
  @Nullable
  public ChannelCounters inputCounters()
  {
    return inputCounters;
  }

  /**
   * User-oriented description, suitable for inclusion in error messages.
   */
  @Nullable
  public String description()
  {
    return description;
  }

  /**
   * Whether this segment is likely cached locally. Generally, this is set to true if the segment was cached locally
   * at the time we created the LoadableSegment object. Because the LoadableSegment object does not have a hold over
   * the segment, it is possible that the segment becomes uncached before {@link #acquire()} is called; hence the
   * "likely" rather than "definitely".
   */
  public boolean isLikelyCached()
  {
    return likelyCached;
  }

  /**
   * Acquire the actual segment. Non-blocking operation. Once this is called, callers are responsible for closing the
   * {@link AcquireSegmentAction}.
   */
  public AcquireSegmentAction acquire()
  {
    if (acquired.compareAndSet(false, true)) {
      return acquireSupplier.get();
    } else {
      throw DruidException.defensive("Segment with descriptor[%s] is already acquired", descriptor);
    }
  }
}
