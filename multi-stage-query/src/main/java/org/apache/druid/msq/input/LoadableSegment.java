/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.druid.msq.input;

import com.google.common.util.concurrent.ListenableFuture;
import org.apache.druid.common.guava.FutureUtils;
import org.apache.druid.error.DruidException;
import org.apache.druid.msq.counters.ChannelCounters;
import org.apache.druid.query.SegmentDescriptor;
import org.apache.druid.segment.Segment;
import org.apache.druid.segment.loading.AcquireSegmentAction;
import org.apache.druid.server.SegmentManager;
import org.apache.druid.timeline.DataSegment;

import javax.annotation.Nullable;
import java.util.Optional;

//
/**
 * Pointer to some data that can be read as a {@link Segment}. These are contained by
 * {@link PhysicalInputSlice#getLoadableSegments()}, which are in turn generated by {@link InputSliceReader#attach}.
 *
 * These objects do not hold resources and do not have a lifecycle. They are just pointers to data that hasn't
 * been acquired yet. Once {@link #acquire()} or {@link #acquireIfCached()} is called, the lifecycle begins.
 *
 * @see RegularLoadableSegment for segments loaded via {@link SegmentManager}
 * @see AdaptedLoadableSegment for segments adapted from other data sources
 */
public interface LoadableSegment
{
  /**
   * Returns the descriptor that is used to query this segment. The interval of this descriptor is particularly
   * important: it acts as a filter on the underlying segment.
   */
  SegmentDescriptor descriptor();

  /**
   * Returns input counters that should be updated as this segment is queried, or null if it is not necessary
   * to update input counters.
   */
  @Nullable
  ChannelCounters inputCounters();

  /**
   * User-oriented description, suitable for inclusion in log or error messages.
   */
  @Nullable
  String description();

  /**
   * Attempts to acquire this segment if it is already cached locally.
   *
   * If the returned {@link Optional} is present, the caller is responsible for closing the {@link Segment}
   * when finished with it. If the returned {@link Optional} is empty, the segment is not cached and the caller
   * should use {@link #acquire()} to load it.
   *
   * @return an Optional containing the cached Segment if available, or empty if not cached
   */
  Optional<Segment> acquireIfCached();

  /**
   * Acquire the actual segment. Non-blocking operation. Once this is called, callers are responsible for closing the
   * {@link AcquireSegmentAction}.
   *
   * @throws DruidException if the segment has already been acquired
   */
  AcquireSegmentAction acquire();

  /**
   * Returns a future for the {@link DataSegment} object. For {@link RegularLoadableSegment}, the future is created
   * lazily when this method is first called, or when a segment is acquired through {@link #acquire()}.
   * For {@link AdaptedLoadableSegment}, this returns a failed future.
   */
  ListenableFuture<DataSegment> dataSegmentFuture();

  /**
   * Returns the {@link DataSegment} object from {@link #dataSegmentFuture()}, blocking until it is available.
   * For {@link RegularLoadableSegment}, the object is guaranteed to be available once the segment has been acquired.
   * For {@link AdaptedLoadableSegment}, this throws an exception.
   */
  default DataSegment dataSegment()
  {
    return FutureUtils.getUnchecked(dataSegmentFuture(), false);
  }
}
