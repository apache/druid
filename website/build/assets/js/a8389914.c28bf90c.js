"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9210],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>N});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=p(n),k=r,N=m["".concat(d,".").concat(k)]||m[k]||u[k]||i;return n?a.createElement(N,l(l({ref:t},s),{},{components:n})):a.createElement(N,l({ref:t},s))}));function N(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=k;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[m]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},4379:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>d,default:()=>k,frontMatter:()=>o,metadata:()=>p,toc:()=>m});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],o={id:"sql-scalar",title:"SQL scalar functions",sidebar_label:"Scalar functions"},d=void 0,p={unversionedId:"querying/sql-scalar",id:"querying/sql-scalar",title:"SQL scalar functions",description:"\x3c!--",source:"@site/../docs/querying/sql-scalar.md",sourceDirName:"querying",slug:"/querying/sql-scalar",permalink:"/docs/querying/sql-scalar",draft:!1,editUrl:"https://github.com/apache/druid/edit/master/docs/../docs/querying/sql-scalar.md",tags:[],version:"current",lastUpdatedBy:"Gian Merlino",lastUpdatedAt:1655841937,formattedLastUpdatedAt:"Jun 21, 2022",frontMatter:{id:"sql-scalar",title:"SQL scalar functions",sidebar_label:"Scalar functions"},sidebar:"docs",previous:{title:"Operators",permalink:"/docs/querying/sql-operators"},next:{title:"Aggregation functions",permalink:"/docs/querying/sql-aggregations"}},s={},m=[{value:"Numeric functions",id:"numeric-functions",level:2},{value:"String functions",id:"string-functions",level:2},{value:"Date and time functions",id:"date-and-time-functions",level:2},{value:"Reduction functions",id:"reduction-functions",level:2},{value:"IP address functions",id:"ip-address-functions",level:2},{value:"Sketch functions",id:"sketch-functions",level:2},{value:"HLL sketch functions",id:"hll-sketch-functions",level:3},{value:"Theta sketch functions",id:"theta-sketch-functions",level:3},{value:"Quantiles sketch functions",id:"quantiles-sketch-functions",level:3},{value:"Other scalar functions",id:"other-scalar-functions",level:2}],u={toc:m};function k(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Apache Druid supports two query languages: Druid SQL and ",(0,i.kt)("a",{parentName:"p",href:"/docs/querying/"},"native queries"),".\nThis document describes the SQL language.")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/querying/sql"},"Druid SQL")," includes scalar functions that include numeric and string functions, IP address functions, Sketch functions, and more, as described on this page. "),(0,i.kt)("h2",{id:"numeric-functions"},"Numeric functions"),(0,i.kt)("p",null,"For mathematical operations, Druid SQL will use integer math if all operands involved in an expression are integers.\nOtherwise, Druid will switch to floating point math. You can force this to happen by casting one of your operands\nto FLOAT. At runtime, Druid will widen 32-bit floats to 64-bit for most expressions."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"PI")),(0,i.kt)("td",{parentName:"tr",align:null},"Constant Pi.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ABS(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Absolute value.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CEIL(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Ceiling.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"EXP(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"e to the power of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"FLOOR(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Floor.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LN(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Logarithm (base e).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LOG10(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Logarithm (base 10).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"POWER(expr, power)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"expr")," raised to the power of ",(0,i.kt)("inlineCode",{parentName:"td"},"power"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"SQRT(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Square root.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TRUNCATE(expr, [digits])")),(0,i.kt)("td",{parentName:"tr",align:null},"Truncate ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," to a specific number of decimal digits. If digits is negative, then this truncates that many places to the left of the decimal point. Digits defaults to zero if not specified.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TRUNC(expr, [digits])")),(0,i.kt)("td",{parentName:"tr",align:null},"Alias for ",(0,i.kt)("inlineCode",{parentName:"td"},"TRUNCATE"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ROUND(expr, [digits])")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ROUND(x, y)")," would return the value of the x rounded to the y decimal places. While x can be an integer or floating-point number, y must be an integer. The type of the return value is specified by that of x. y defaults to 0 if omitted. When y is negative, x is rounded on the left side of the y decimal points. If ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," evaluates to either ",(0,i.kt)("inlineCode",{parentName:"td"},"NaN"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," will be converted to 0. If ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," is infinity, ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," will be converted to the nearest finite double.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"MOD(x, y)")),(0,i.kt)("td",{parentName:"tr",align:null},"Modulo (remainder of x divided by y).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"SIN(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Trigonometric sine of an angle ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"COS(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Trigonometric cosine of an angle ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TAN(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Trigonometric tangent of an angle ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"COT(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Trigonometric cotangent of an angle ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ASIN(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Arc sine of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ACOS(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Arc cosine of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ATAN(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Arc tangent of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ATAN2(y, x)")),(0,i.kt)("td",{parentName:"tr",align:null},"Angle theta from the conversion of rectangular coordinates (x, y) to polar * coordinates (r, theta).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DEGREES(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Converts an angle measured in radians to an approximately equivalent angle measured in degrees.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RADIANS(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Converts an angle measured in degrees to an approximately equivalent angle measured in radians.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_AND(expr1, expr2)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the result of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr1 & expr2"),". Double values will be implicitly cast to longs, use ",(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_CONVERT_DOUBLE_TO_LONG_BITS")," to perform bitwise operations directly with doubles.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_COMPLEMENT(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the result of ",(0,i.kt)("inlineCode",{parentName:"td"},"~expr"),". Double values will be implicitly cast to longs, use ",(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_CONVERT_DOUBLE_TO_LONG_BITS")," to perform bitwise operations directly with doubles.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_CONVERT_DOUBLE_TO_LONG_BITS(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Converts the bits of an IEEE 754 floating-point double value to a long. If the input is not a double, it is implicitly cast to a double prior to conversion.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_CONVERT_LONG_BITS_TO_DOUBLE(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Converts a long to the IEEE 754 floating-point double specified by the bits stored in the long. If the input is not a long, it is implicitly cast to a long prior to conversion.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_OR(expr1, expr2)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the result of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr1 [PIPE] expr2"),". Double values will be implicitly cast to longs, use ",(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_CONVERT_DOUBLE_TO_LONG_BITS")," to perform bitwise operations directly with doubles.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_SHIFT_LEFT(expr1, expr2)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the result of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr1 << expr2"),". Double values will be implicitly cast to longs, use ",(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_CONVERT_DOUBLE_TO_LONG_BITS")," to perform bitwise operations directly with doubles.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_SHIFT_RIGHT(expr1, expr2)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the result of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr1 >> expr2"),". Double values will be implicitly cast to longs, use ",(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_CONVERT_DOUBLE_TO_LONG_BITS")," to perform bitwise operations directly with doubles.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_XOR(expr1, expr2)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the result of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr1 ^ expr2"),". Double values will be implicitly cast to longs, use ",(0,i.kt)("inlineCode",{parentName:"td"},"BITWISE_CONVERT_DOUBLE_TO_LONG_BITS")," to perform bitwise operations directly with doubles.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DIV(x, y)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the result of integer division of x by y")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"HUMAN_READABLE_BINARY_BYTE_FORMAT(value, [precision])")),(0,i.kt)("td",{parentName:"tr",align:null},"Format a number in human-readable ",(0,i.kt)("a",{parentName:"td",href:"https://en.wikipedia.org/wiki/Binary_prefix"},"IEC")," format. For example, HUMAN_READABLE_BINARY_BYTE_FORMAT(1048576) returns ",(0,i.kt)("inlineCode",{parentName:"td"},"1.00 MiB"),". ",(0,i.kt)("inlineCode",{parentName:"td"},"precision")," must be in the range of ",(0,i.kt)("inlineCode",{parentName:"td"},"[0, 3]")," (default: 2).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"HUMAN_READABLE_DECIMAL_BYTE_FORMAT(value, [precision])")),(0,i.kt)("td",{parentName:"tr",align:null},"Format a number in human-readable ",(0,i.kt)("a",{parentName:"td",href:"https://en.wikipedia.org/wiki/Binary_prefix"},"SI")," format. HUMAN_READABLE_DECIMAL_BYTE_FORMAT(1048576) returns ",(0,i.kt)("inlineCode",{parentName:"td"},"1.04 MB"),". ",(0,i.kt)("inlineCode",{parentName:"td"},"precision")," must be in the range of ",(0,i.kt)("inlineCode",{parentName:"td"},"[0, 3]")," (default: 2). ",(0,i.kt)("inlineCode",{parentName:"td"},"precision")," must be in the range of ",(0,i.kt)("inlineCode",{parentName:"td"},"[0, 3]")," (default: 2).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"HUMAN_READABLE_DECIMAL_FORMAT(value, [precision])")),(0,i.kt)("td",{parentName:"tr",align:null},"Format a number in human-readable SI format. For example, HUMAN_READABLE_DECIMAL_FORMAT(1048576) returns ",(0,i.kt)("inlineCode",{parentName:"td"},"1.04 M"),". ",(0,i.kt)("inlineCode",{parentName:"td"},"precision")," must be in the range of ",(0,i.kt)("inlineCode",{parentName:"td"},"[0, 3]")," (default: 2).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"SAFE_DIVIDE(x, y)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the division of x by y guarded on division by 0. In case y is 0 it returns 0, or ",(0,i.kt)("inlineCode",{parentName:"td"},"null")," if ",(0,i.kt)("inlineCode",{parentName:"td"},"druid.generic.useDefaultValueForNull=false"))))),(0,i.kt)("h2",{id:"string-functions"},"String functions"),(0,i.kt)("p",null,"String functions accept strings, and return a type appropriate to the function."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CONCAT(expr, expr...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Concats a list of expressions. Also see the ",(0,i.kt)("a",{parentName:"td",href:"/docs/querying/sql-operators#concatenation-operator"},"concatenation operator"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TEXTCAT(expr, expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Two argument version of ",(0,i.kt)("inlineCode",{parentName:"td"},"CONCAT"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"STRING_FORMAT(pattern, [args...])")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a string formatted in the manner of Java's ",(0,i.kt)("a",{parentName:"td",href:"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-"},"String.format"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LENGTH(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Length of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," in UTF-16 code units.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CHAR_LENGTH(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Alias for ",(0,i.kt)("inlineCode",{parentName:"td"},"LENGTH"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CHARACTER_LENGTH(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Alias for ",(0,i.kt)("inlineCode",{parentName:"td"},"LENGTH"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"STRLEN(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Alias for ",(0,i.kt)("inlineCode",{parentName:"td"},"LENGTH"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LOOKUP(expr, lookupName)")),(0,i.kt)("td",{parentName:"tr",align:null},"Look up ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," in a registered ",(0,i.kt)("a",{parentName:"td",href:"/docs/querying/lookups"},"query-time lookup table"),". Note that lookups can also be queried directly using the ",(0,i.kt)("a",{parentName:"td",href:"/docs/querying/sql#from"},(0,i.kt)("inlineCode",{parentName:"a"},"lookup")," schema"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LOWER(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," in all lowercase.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UPPER(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," in all uppercase.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"PARSE_LONG(string, [radix])")),(0,i.kt)("td",{parentName:"tr",align:null},"Parses a string into a long (BIGINT) with the given radix, or 10 (decimal) if a radix is not provided.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"POSITION(needle IN haystack [FROM fromIndex])")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the index of ",(0,i.kt)("inlineCode",{parentName:"td"},"needle")," within ",(0,i.kt)("inlineCode",{parentName:"td"},"haystack"),", with indexes starting from 1. The search will begin at ",(0,i.kt)("inlineCode",{parentName:"td"},"fromIndex"),", or 1 if ",(0,i.kt)("inlineCode",{parentName:"td"},"fromIndex")," is not specified. If ",(0,i.kt)("inlineCode",{parentName:"td"},"needle")," is not found, returns 0.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"REGEXP_EXTRACT(expr, pattern, [index])")),(0,i.kt)("td",{parentName:"tr",align:null},"Apply regular expression ",(0,i.kt)("inlineCode",{parentName:"td"},"pattern")," to ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," and extract a capture group, or ",(0,i.kt)("inlineCode",{parentName:"td"},"NULL")," if there is no match. If index is unspecified or zero, returns the first substring that matched the pattern. The pattern may match anywhere inside ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),"; if you want to match the entire string instead, use the ",(0,i.kt)("inlineCode",{parentName:"td"},"^")," and ",(0,i.kt)("inlineCode",{parentName:"td"},"$")," markers at the start and end of your pattern. Note: when ",(0,i.kt)("inlineCode",{parentName:"td"},"druid.generic.useDefaultValueForNull = true"),", it is not possible to differentiate an empty-string match from a non-match (both will return ",(0,i.kt)("inlineCode",{parentName:"td"},"NULL"),").")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"REGEXP_LIKE(expr, pattern)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns whether ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," matches regular expression ",(0,i.kt)("inlineCode",{parentName:"td"},"pattern"),". The pattern may match anywhere inside ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),"; if you want to match the entire string instead, use the ",(0,i.kt)("inlineCode",{parentName:"td"},"^")," and ",(0,i.kt)("inlineCode",{parentName:"td"},"$")," markers at the start and end of your pattern. Similar to ",(0,i.kt)("a",{parentName:"td",href:"/docs/querying/sql-operators#logical-operators"},(0,i.kt)("inlineCode",{parentName:"a"},"LIKE")),", but uses regexps instead of LIKE patterns. Especially useful in WHERE clauses.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CONTAINS_STRING(expr, str)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns true if the ",(0,i.kt)("inlineCode",{parentName:"td"},"str")," is a substring of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ICONTAINS_STRING(expr, str)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns true if the ",(0,i.kt)("inlineCode",{parentName:"td"},"str")," is a substring of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),". The match is case-insensitive.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"REPLACE(expr, pattern, replacement)")),(0,i.kt)("td",{parentName:"tr",align:null},"Replaces pattern with replacement in ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),", and returns the result.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"STRPOS(haystack, needle)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the index of ",(0,i.kt)("inlineCode",{parentName:"td"},"needle")," within ",(0,i.kt)("inlineCode",{parentName:"td"},"haystack"),", with indexes starting from 1. If ",(0,i.kt)("inlineCode",{parentName:"td"},"needle")," is not found, returns 0.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"SUBSTRING(expr, index, [length])")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a substring of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," starting at index, with a max length, both measured in UTF-16 code units.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RIGHT(expr, [length])")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the rightmost length characters from ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LEFT(expr, [length])")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the leftmost length characters from ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"SUBSTR(expr, index, [length])")),(0,i.kt)("td",{parentName:"tr",align:null},"Alias for ",(0,i.kt)("inlineCode",{parentName:"td"},"SUBSTRING"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TRIM([BOTH "),(0,i.kt)("code",null,"|"),(0,i.kt)("inlineCode",{parentName:"td"},"LEADING"),(0,i.kt)("code",null,"|"),(0,i.kt)("inlineCode",{parentName:"td"}," TRAILING] [chars FROM] expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),' with characters removed from the leading, trailing, or both ends of "expr" if they are in "chars". If "chars" is not provided, it defaults to " " (a space). If the directional argument is not provided, it defaults to "BOTH".')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BTRIM(expr, [chars])")),(0,i.kt)("td",{parentName:"tr",align:null},"Alternate form of ",(0,i.kt)("inlineCode",{parentName:"td"},"TRIM(BOTH chars FROM expr)"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LTRIM(expr, [chars])")),(0,i.kt)("td",{parentName:"tr",align:null},"Alternate form of ",(0,i.kt)("inlineCode",{parentName:"td"},"TRIM(LEADING chars FROM expr)"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RTRIM(expr, [chars])")),(0,i.kt)("td",{parentName:"tr",align:null},"Alternate form of ",(0,i.kt)("inlineCode",{parentName:"td"},"TRIM(TRAILING chars FROM expr)"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"REVERSE(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Reverses ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"REPEAT(expr, [N])")),(0,i.kt)("td",{parentName:"tr",align:null},"Repeats ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," N times")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LPAD(expr, length, [chars])")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a string of ",(0,i.kt)("inlineCode",{parentName:"td"},"length")," from ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," left-padded with ",(0,i.kt)("inlineCode",{parentName:"td"},"chars"),". If ",(0,i.kt)("inlineCode",{parentName:"td"},"length")," is shorter than the length of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),", the result is ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," which is truncated to ",(0,i.kt)("inlineCode",{parentName:"td"},"length"),". The result will be null if either ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"chars")," is null. If ",(0,i.kt)("inlineCode",{parentName:"td"},"chars")," is an empty string, no padding is added, however ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," may be trimmed if necessary.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"RPAD(expr, length, [chars])")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a string of ",(0,i.kt)("inlineCode",{parentName:"td"},"length")," from ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," right-padded with ",(0,i.kt)("inlineCode",{parentName:"td"},"chars"),". If ",(0,i.kt)("inlineCode",{parentName:"td"},"length")," is shorter than the length of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),", the result is ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," which is truncated to ",(0,i.kt)("inlineCode",{parentName:"td"},"length"),". The result will be null if either ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"chars")," is null. If ",(0,i.kt)("inlineCode",{parentName:"td"},"chars")," is an empty string, no padding is added, however ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," may be trimmed if necessary.")))),(0,i.kt)("h2",{id:"date-and-time-functions"},"Date and time functions"),(0,i.kt)("p",null,"Time functions can be used with:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Druid's primary timestamp column, ",(0,i.kt)("inlineCode",{parentName:"li"},"__time"),";"),(0,i.kt)("li",{parentName:"ul"},"Numeric values representing milliseconds since the epoch, through the MILLIS_TO_TIMESTAMP function; and"),(0,i.kt)("li",{parentName:"ul"},"String timestamps, through the TIME_PARSE function.")),(0,i.kt)("p",null,"By default, time operations use the UTC time zone. You can change the time zone by setting the connection\ncontext parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlTimeZone")," to the name of another time zone, like ",(0,i.kt)("inlineCode",{parentName:"p"},"America/Los_Angeles"),", or to an offset like\n",(0,i.kt)("inlineCode",{parentName:"p"},"-08:00"),". If you need to mix multiple time zones in the same query, or if you need to use a time zone other than\nthe connection time zone, some functions also accept time zones as parameters. These parameters always take precedence\nover the connection time zone."),(0,i.kt)("p",null,"Literal timestamps in the connection time zone can be written using ",(0,i.kt)("inlineCode",{parentName:"p"},"TIMESTAMP '2000-01-01 00:00:00'")," syntax. The\nsimplest way to write literal timestamps in other time zones is to use TIME_PARSE, like\n",(0,i.kt)("inlineCode",{parentName:"p"},"TIME_PARSE('2000-02-01 00:00:00', NULL, 'America/Los_Angeles')"),"."),(0,i.kt)("p",null,"The best ways to filter based on time are by using ISO8601 intervals, like\n",(0,i.kt)("inlineCode",{parentName:"p"},"TIME_IN_INTERVAL(__time, '2000-01-01/2000-02-01')"),", or by using literal timestamps with the ",(0,i.kt)("inlineCode",{parentName:"p"},">=")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<")," operators, like\n",(0,i.kt)("inlineCode",{parentName:"p"},"__time >= TIMESTAMP '2000-01-01 00:00:00' AND __time < TIMESTAMP '2000-02-01 00:00:00'"),"."),(0,i.kt)("p",null,"Druid supports the standard SQL BETWEEN operator, but we recommend avoiding it for time filters. BETWEEN is inclusive\nof its upper bound, which makes it awkward to write time filters correctly. For example, the equivalent of\n",(0,i.kt)("inlineCode",{parentName:"p"},"TIME_IN_INTERVAL(__time, '2000-01-01/2000-02-01')")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"__time BETWEEN TIMESTAMP '2000-01-01 00:00:00' AND TIMESTAMP '2000-01-31 23:59:59.999'"),"."),(0,i.kt)("p",null,"Druid processes timestamps internally as longs (64-bit integers) representing milliseconds since the epoch. Therefore,\ntime functions perform best when used with the primary timestamp column, or with timestamps stored in long columns as\nmilliseconds and accessed with MILLIS_TO_TIMESTAMP. Other timestamp representations, include string timestamps and\nPOSIX timestamps (seconds since the epoch) require query-time conversion to Druid's internal form, which adds additional\noverhead."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CURRENT_TIMESTAMP")),(0,i.kt)("td",{parentName:"tr",align:null},"Current timestamp in the connection's time zone.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CURRENT_DATE")),(0,i.kt)("td",{parentName:"tr",align:null},"Current date in the connection's time zone.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DATE_TRUNC(unit, timestamp_expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Rounds down a timestamp, returning it as a new timestamp. Unit can be 'milliseconds', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year', 'decade', 'century', or 'millennium'.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIME_CEIL(timestamp_expr, period, [origin, [timezone]])")),(0,i.kt)("td",{parentName:"tr",align:null},"Rounds up a timestamp, returning it as a new timestamp. Period can be any ISO8601 period, like P3M (quarters) or PT12H (half-days). Specify ",(0,i.kt)("inlineCode",{parentName:"td"},"origin")," as a timestamp to set the reference time for rounding. For example, ",(0,i.kt)("inlineCode",{parentName:"td"},"TIME_CEIL(__time, 'PT1H', TIMESTAMP '2016-06-27 00:30:00')")," measures an hourly period from 00:30-01:30 instead of 00:00-01:00. See ",(0,i.kt)("a",{parentName:"td",href:"/docs/querying/granularities"},"Period granularities"),' for details on the default starting boundaries. The time zone, if provided, should be a time zone name like "America/Los_Angeles" or offset like "-08:00". This function is similar to ',(0,i.kt)("inlineCode",{parentName:"td"},"CEIL")," but is more flexible.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIME_FLOOR(timestamp_expr, period, [origin, [timezone]])")),(0,i.kt)("td",{parentName:"tr",align:null},"Rounds down a timestamp, returning it as a new timestamp. Period can be any ISO8601 period, like P3M (quarters) or PT12H (half-days). Specify ",(0,i.kt)("inlineCode",{parentName:"td"},"origin")," as a timestamp to set the reference time for rounding. For example, ",(0,i.kt)("inlineCode",{parentName:"td"},"TIME_FLOOR(__time, 'PT1H', TIMESTAMP '2016-06-27 00:30:00')")," measures an hourly period from 00:30-01:30 instead of 00:00-01:00. See ",(0,i.kt)("a",{parentName:"td",href:"/docs/querying/granularities"},"Period granularities"),' for details on the default starting boundaries. The time zone, if provided, should be a time zone name like "America/Los_Angeles" or offset like "-08:00". This function is similar to ',(0,i.kt)("inlineCode",{parentName:"td"},"FLOOR")," but is more flexible.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIME_SHIFT(timestamp_expr, period, step, [timezone])")),(0,i.kt)("td",{parentName:"tr",align:null},'Shifts a timestamp by a period (step times), returning it as a new timestamp. Period can be any ISO8601 period. Step may be negative. The time zone, if provided, should be a time zone name like "America/Los_Angeles" or offset like "-08:00".')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIME_EXTRACT(timestamp_expr, [unit, [timezone]])")),(0,i.kt)("td",{parentName:"tr",align:null},"Extracts a time part from ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),", returning it as a number. Unit can be EPOCH, SECOND, MINUTE, HOUR, DAY (day of month), DOW (day of week), DOY (day of year), WEEK (week of ",(0,i.kt)("a",{parentName:"td",href:"https://en.wikipedia.org/wiki/ISO_week_date"},"week year"),'), MONTH (1 through 12), QUARTER (1 through 4), or YEAR. The time zone, if provided, should be a time zone name like "America/Los_Angeles" or offset like "-08:00". This function is similar to ',(0,i.kt)("inlineCode",{parentName:"td"},"EXTRACT")," but is more flexible. Unit and time zone must be literals, and must be provided quoted, like ",(0,i.kt)("inlineCode",{parentName:"td"},"TIME_EXTRACT(__time, 'HOUR')")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"TIME_EXTRACT(__time, 'HOUR', 'America/Los_Angeles')"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIME_PARSE(string_expr, [pattern, [timezone]])")),(0,i.kt)("td",{parentName:"tr",align:null},"Parses a string into a timestamp using a given ",(0,i.kt)("a",{parentName:"td",href:"http://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormat.html"},"Joda DateTimeFormat pattern"),", or ISO8601 (e.g. ",(0,i.kt)("inlineCode",{parentName:"td"},"2000-01-02T03:04:05Z"),') if the pattern is not provided. The time zone, if provided, should be a time zone name like "America/Los_Angeles" or offset like "-08:00", and will be used as the time zone for strings that do not include a time zone offset. Pattern and time zone must be literals. Strings that cannot be parsed as timestamps will be returned as NULL.')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIME_FORMAT(timestamp_expr, [pattern, [timezone]])")),(0,i.kt)("td",{parentName:"tr",align:null},"Formats a timestamp as a string with a given ",(0,i.kt)("a",{parentName:"td",href:"http://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormat.html"},"Joda DateTimeFormat pattern"),", or ISO8601 (e.g. ",(0,i.kt)("inlineCode",{parentName:"td"},"2000-01-02T03:04:05Z"),') if the pattern is not provided. The time zone, if provided, should be a time zone name like "America/Los_Angeles" or offset like "-08:00". Pattern and time zone must be literals.')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIME_IN_INTERVAL(timestamp_expr, interval)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns whether a timestamp is contained within a particular interval. The interval must be a literal string containing any ISO8601 interval, such as ",(0,i.kt)("inlineCode",{parentName:"td"},"'2001-01-01/P1D'")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"'2001-01-01T01:00:00/2001-01-02T01:00:00'"),". The start instant of the interval is inclusive and the end instant is exclusive.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"MILLIS_TO_TIMESTAMP(millis_expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Converts a number of milliseconds since the epoch (1970-01-01 00:00:00 UTC) into a timestamp.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIMESTAMP_TO_MILLIS(timestamp_expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Converts a timestamp into a number of milliseconds since the epoch.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"EXTRACT(unit FROM timestamp_expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Extracts a time part from ",(0,i.kt)("inlineCode",{parentName:"td"},"expr"),", returning it as a number. Unit can be EPOCH, MICROSECOND, MILLISECOND, SECOND, MINUTE, HOUR, DAY (day of month), DOW (day of week), ISODOW (ISO day of week), DOY (day of year), WEEK (week of year), MONTH, QUARTER, YEAR, ISOYEAR, DECADE, CENTURY or MILLENNIUM. Units must be provided unquoted, like ",(0,i.kt)("inlineCode",{parentName:"td"},"EXTRACT(HOUR FROM __time)"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"FLOOR(timestamp_expr TO unit)")),(0,i.kt)("td",{parentName:"tr",align:null},"Rounds down a timestamp, returning it as a new timestamp. Unit can be SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, or YEAR.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CEIL(timestamp_expr TO unit)")),(0,i.kt)("td",{parentName:"tr",align:null},"Rounds up a timestamp, returning it as a new timestamp. Unit can be SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, or YEAR.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIMESTAMPADD(unit, count, timestamp)")),(0,i.kt)("td",{parentName:"tr",align:null},"Equivalent to ",(0,i.kt)("inlineCode",{parentName:"td"},"timestamp + count * INTERVAL '1' UNIT"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TIMESTAMPDIFF(unit, timestamp1, timestamp2)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the (signed) number of ",(0,i.kt)("inlineCode",{parentName:"td"},"unit")," between ",(0,i.kt)("inlineCode",{parentName:"td"},"timestamp1")," and ",(0,i.kt)("inlineCode",{parentName:"td"},"timestamp2"),". Unit can be SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, or YEAR.")))),(0,i.kt)("h2",{id:"reduction-functions"},"Reduction functions"),(0,i.kt)("p",null,"Reduction functions operate on zero or more expressions and return a single expression. If no expressions are passed as\narguments, then the result is ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL"),". The expressions must all be convertible to a common data type, which will be the\ntype of the result:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If all argument are ",(0,i.kt)("inlineCode",{parentName:"li"},"NULL"),", the result is ",(0,i.kt)("inlineCode",{parentName:"li"},"NULL"),". Otherwise, ",(0,i.kt)("inlineCode",{parentName:"li"},"NULL")," arguments are ignored."),(0,i.kt)("li",{parentName:"ul"},"If the arguments comprise a mix of numbers and strings, the arguments are interpreted as strings."),(0,i.kt)("li",{parentName:"ul"},"If all arguments are integer numbers, the arguments are interpreted as longs."),(0,i.kt)("li",{parentName:"ul"},"If all arguments are numbers and at least one argument is a double, the arguments are interpreted as doubles. ")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"GREATEST([expr1, ...])")),(0,i.kt)("td",{parentName:"tr",align:null},"Evaluates zero or more expressions and returns the maximum value based on comparisons as described above.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"LEAST([expr1, ...])")),(0,i.kt)("td",{parentName:"tr",align:null},"Evaluates zero or more expressions and returns the minimum value based on comparisons as described above.")))),(0,i.kt)("h2",{id:"ip-address-functions"},"IP address functions"),(0,i.kt)("p",null,"For the IPv4 address functions, the ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),' argument can either be an IPv4 dotted-decimal string\n(e.g., "192.168.0.1") or an IP address represented as an integer (e.g., 3232235521). The ',(0,i.kt)("inlineCode",{parentName:"p"},"subnet"),'\nargument should be a string formatted as an IPv4 address subnet in CIDR notation (e.g., "192.168.0.0/16").'),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"IPV4_MATCH(address, subnet)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns true if the ",(0,i.kt)("inlineCode",{parentName:"td"},"address")," belongs to the ",(0,i.kt)("inlineCode",{parentName:"td"},"subnet")," literal, else false. If ",(0,i.kt)("inlineCode",{parentName:"td"},"address")," is not a valid IPv4 address, then false is returned. This function is more efficient if ",(0,i.kt)("inlineCode",{parentName:"td"},"address")," is an integer instead of a string.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"IPV4_PARSE(address)")),(0,i.kt)("td",{parentName:"tr",align:null},"Parses ",(0,i.kt)("inlineCode",{parentName:"td"},"address")," into an IPv4 address stored as an integer . If ",(0,i.kt)("inlineCode",{parentName:"td"},"address")," is an integer that is a valid IPv4 address, then it is passed through. Returns null if ",(0,i.kt)("inlineCode",{parentName:"td"},"address")," cannot be represented as an IPv4 address.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"IPV4_STRINGIFY(address)")),(0,i.kt)("td",{parentName:"tr",align:null},"Converts ",(0,i.kt)("inlineCode",{parentName:"td"},"address")," into an IPv4 address dotted-decimal string. If ",(0,i.kt)("inlineCode",{parentName:"td"},"address")," is a string that is a valid IPv4 address, then it is passed through. Returns null if ",(0,i.kt)("inlineCode",{parentName:"td"},"address")," cannot be represented as an IPv4 address.")))),(0,i.kt)("h2",{id:"sketch-functions"},"Sketch functions"),(0,i.kt)("p",null,"These functions operate on expressions or columns that return sketch objects.\nTo create sketch objects, see the ",(0,i.kt)("a",{parentName:"p",href:"/docs/querying/sql-aggregations#sketch-functions"},"DataSketches aggregators"),"."),(0,i.kt)("h3",{id:"hll-sketch-functions"},"HLL sketch functions"),(0,i.kt)("p",null,"The following functions operate on ",(0,i.kt)("a",{parentName:"p",href:"/docs/development/extensions-core/datasketches-hll"},"DataSketches HLL sketches"),".\nThe ",(0,i.kt)("a",{parentName:"p",href:"/docs/development/extensions-core/datasketches-extension"},"DataSketches extension")," must be loaded to use the following functions."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"HLL_SKETCH_ESTIMATE(expr, [round])")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the distinct count estimate from an HLL sketch. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return an HLL sketch. The optional ",(0,i.kt)("inlineCode",{parentName:"td"},"round")," boolean parameter will round the estimate if set to ",(0,i.kt)("inlineCode",{parentName:"td"},"true"),", with a default of ",(0,i.kt)("inlineCode",{parentName:"td"},"false"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"HLL_SKETCH_ESTIMATE_WITH_ERROR_BOUNDS(expr, [numStdDev])")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the distinct count estimate and error bounds from an HLL sketch. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return an HLL sketch. An optional ",(0,i.kt)("inlineCode",{parentName:"td"},"numStdDev")," argument can be provided.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"HLL_SKETCH_UNION([lgK, tgtHllType], expr0, expr1, ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a union of HLL sketches, where each input expression must return an HLL sketch. The ",(0,i.kt)("inlineCode",{parentName:"td"},"lgK")," and ",(0,i.kt)("inlineCode",{parentName:"td"},"tgtHllType")," can be optionally specified as the first parameter; if provided, both optional parameters must be specified.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"HLL_SKETCH_TO_STRING(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a human-readable string representation of an HLL sketch for debugging. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return an HLL sketch.")))),(0,i.kt)("h3",{id:"theta-sketch-functions"},"Theta sketch functions"),(0,i.kt)("p",null,"The following functions operate on ",(0,i.kt)("a",{parentName:"p",href:"/docs/development/extensions-core/datasketches-theta"},"theta sketches"),".\nThe ",(0,i.kt)("a",{parentName:"p",href:"/docs/development/extensions-core/datasketches-extension"},"DataSketches extension")," must be loaded to use the following functions."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"THETA_SKETCH_ESTIMATE(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the distinct count estimate from a theta sketch. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return a theta sketch.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"THETA_SKETCH_ESTIMATE_WITH_ERROR_BOUNDS(expr, errorBoundsStdDev)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the distinct count estimate and error bounds from a theta sketch. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return a theta sketch.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"THETA_SKETCH_UNION([size], expr0, expr1, ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a union of theta sketches, where each input expression must return a theta sketch. The ",(0,i.kt)("inlineCode",{parentName:"td"},"size")," can be optionally specified as the first parameter.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"THETA_SKETCH_INTERSECT([size], expr0, expr1, ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns an intersection of theta sketches, where each input expression must return a theta sketch. The ",(0,i.kt)("inlineCode",{parentName:"td"},"size")," can be optionally specified as the first parameter.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"THETA_SKETCH_NOT([size], expr0, expr1, ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a set difference of theta sketches, where each input expression must return a theta sketch. The ",(0,i.kt)("inlineCode",{parentName:"td"},"size")," can be optionally specified as the first parameter.")))),(0,i.kt)("h3",{id:"quantiles-sketch-functions"},"Quantiles sketch functions"),(0,i.kt)("p",null,"The following functions operate on ",(0,i.kt)("a",{parentName:"p",href:"/docs/development/extensions-core/datasketches-quantiles"},"quantiles sketches"),".\nThe ",(0,i.kt)("a",{parentName:"p",href:"/docs/development/extensions-core/datasketches-extension"},"DataSketches extension")," must be loaded to use the following functions."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DS_GET_QUANTILE(expr, fraction)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the quantile estimate corresponding to ",(0,i.kt)("inlineCode",{parentName:"td"},"fraction")," from a quantiles sketch. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return a quantiles sketch.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DS_GET_QUANTILES(expr, fraction0, fraction1, ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a string representing an array of quantile estimates corresponding to a list of fractions from a quantiles sketch. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return a quantiles sketch.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DS_HISTOGRAM(expr, splitPoint0, splitPoint1, ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a string representing an approximation to the histogram given a list of split points that define the histogram bins from a quantiles sketch. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return a quantiles sketch.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DS_CDF(expr, splitPoint0, splitPoint1, ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a string representing approximation to the Cumulative Distribution Function given a list of split points that define the edges of the bins from a quantiles sketch. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return a quantiles sketch.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DS_RANK(expr, value)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns an approximation to the rank of a given value that is the fraction of the distribution less than that value from a quantiles sketch. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return a quantiles sketch.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"DS_QUANTILE_SUMMARY(expr)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns a string summary of a quantiles sketch, useful for debugging. ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," must return a quantiles sketch.")))),(0,i.kt)("h2",{id:"other-scalar-functions"},"Other scalar functions"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CAST(value AS TYPE)")),(0,i.kt)("td",{parentName:"tr",align:null},"Cast value to another type. See ",(0,i.kt)("a",{parentName:"td",href:"/docs/querying/sql-data-types"},"Data types")," for details about how Druid SQL handles CAST.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CASE expr WHEN value1 THEN result1 \\[ WHEN value2 THEN result2 ... \\] \\[ ELSE resultN \\] END")),(0,i.kt)("td",{parentName:"tr",align:null},"Simple CASE.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CASE WHEN boolean_expr1 THEN result1 \\[ WHEN boolean_expr2 THEN result2 ... \\] \\[ ELSE resultN \\] END")),(0,i.kt)("td",{parentName:"tr",align:null},"Searched CASE.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"NULLIF(value1, value2)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns NULL if value1 and value2 match, else returns value1.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"COALESCE(value1, value2, ...)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns the first value that is neither NULL nor empty string.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"NVL(expr, expr-for-null)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns ",(0,i.kt)("inlineCode",{parentName:"td"},"expr-for-null")," if ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," is null (or empty string for string type).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"BLOOM_FILTER_TEST(expr, serialized-filter)")),(0,i.kt)("td",{parentName:"tr",align:null},"Returns true if the value of ",(0,i.kt)("inlineCode",{parentName:"td"},"expr")," is contained in the Base64-serialized Bloom filter. See the ",(0,i.kt)("a",{parentName:"td",href:"/docs/development/extensions-core/bloom-filter"},"Bloom filter extension")," documentation for additional details. See the ",(0,i.kt)("a",{parentName:"td",href:"/docs/querying/sql-aggregations"},(0,i.kt)("inlineCode",{parentName:"a"},"BLOOM_FILTER")," function")," for computing Bloom filters.")))))}k.isMDXComponent=!0}}]);