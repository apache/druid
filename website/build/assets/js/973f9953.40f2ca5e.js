"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1015],{3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>k});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function s(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var o=n.createContext({}),d=function(t){var e=n.useContext(o),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},m=function(t){var e=d(t.components);return n.createElement(o.Provider,{value:e},t.children)},p="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},N=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,o=t.parentName,m=s(t,["components","mdxType","originalType","parentName"]),p=d(a),N=r,k=p["".concat(o,".").concat(N)]||p[N]||u[N]||l;return a?n.createElement(k,i(i({ref:e},m),{},{components:a})):n.createElement(k,i({ref:e},m))}));function k(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=N;var s={};for(var o in e)hasOwnProperty.call(e,o)&&(s[o]=e[o]);s.originalType=t,s[p]="string"==typeof t?t:r,i[1]=s;for(var d=2;d<l;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}N.displayName="MDXCreateElement"},3997:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>m,contentTitle:()=>o,default:()=>N,frontMatter:()=>s,metadata:()=>d,toc:()=>p});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=["components"],s={id:"sql-metadata-tables",title:"SQL metadata tables",sidebar_label:"SQL metadata tables"},o=void 0,d={unversionedId:"querying/sql-metadata-tables",id:"querying/sql-metadata-tables",title:"SQL metadata tables",description:"\x3c!--",source:"@site/../docs/querying/sql-metadata-tables.md",sourceDirName:"querying",slug:"/querying/sql-metadata-tables",permalink:"/docs/querying/sql-metadata-tables",draft:!1,editUrl:"https://github.com/apache/druid/edit/master/docs/../docs/querying/sql-metadata-tables.md",tags:[],version:"current",lastUpdatedBy:"Vadim Ogievetsky",lastUpdatedAt:1673566191,formattedLastUpdatedAt:"Jan 12, 2023",frontMatter:{id:"sql-metadata-tables",title:"SQL metadata tables",sidebar_label:"SQL metadata tables"},sidebar:"docs",previous:{title:"SQL query context",permalink:"/docs/querying/sql-query-context"},next:{title:"SQL query translation",permalink:"/docs/querying/sql-translation"}},m={},p=[{value:"INFORMATION SCHEMA",id:"information-schema",level:2},{value:"SCHEMATA table",id:"schemata-table",level:3},{value:"TABLES table",id:"tables-table",level:3},{value:"COLUMNS table",id:"columns-table",level:3},{value:"SYSTEM SCHEMA",id:"system-schema",level:2},{value:"SEGMENTS table",id:"segments-table",level:3},{value:"SERVERS table",id:"servers-table",level:3},{value:"SERVER_SEGMENTS table",id:"server_segments-table",level:3},{value:"TASKS table",id:"tasks-table",level:3},{value:"SUPERVISORS table",id:"supervisors-table",level:3}],u={toc:p};function N(t){var e=t.components,a=(0,r.Z)(t,i);return(0,l.kt)("wrapper",(0,n.Z)({},u,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Apache Druid supports two query languages: Druid SQL and ",(0,l.kt)("a",{parentName:"p",href:"/docs/querying/"},"native queries"),".\nThis document describes the SQL language.")),(0,l.kt)("p",null,"Druid Brokers infer table and column metadata for each datasource from segments loaded in the cluster, and use this to\nplan ",(0,l.kt)("a",{parentName:"p",href:"/docs/querying/sql"},"SQL queries"),". This metadata is cached on Broker startup and also updated periodically in the background through\n",(0,l.kt)("a",{parentName:"p",href:"/docs/querying/segmentmetadataquery"},"SegmentMetadata queries"),". Background metadata refreshing is triggered by\nsegments entering and exiting the cluster, and can also be throttled through configuration."),(0,l.kt)("p",null,'Druid exposes system information through special system tables. There are two such schemas available: Information Schema and Sys Schema.\nInformation schema provides details about table and column types. The "sys" schema provides information about Druid internals like segments/tasks/servers.'),(0,l.kt)("h2",{id:"information-schema"},"INFORMATION SCHEMA"),(0,l.kt)("p",null,"You can access table and column metadata through JDBC using ",(0,l.kt)("inlineCode",{parentName:"p"},"connection.getMetaData()"),', or through the\nINFORMATION_SCHEMA tables described below. For example, to retrieve metadata for the Druid\ndatasource "foo", use the query:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT *\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE \"TABLE_SCHEMA\" = 'druid' AND \"TABLE_NAME\" = 'foo'\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Note: INFORMATION_SCHEMA tables do not currently support Druid-specific functions like ",(0,l.kt)("inlineCode",{parentName:"p"},"TIME_PARSE")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"APPROX_QUANTILE_DS"),". Only standard SQL functions can be used.")),(0,l.kt)("h3",{id:"schemata-table"},"SCHEMATA table"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"INFORMATION_SCHEMA.SCHEMATA")," provides a list of all known schemas, which include ",(0,l.kt)("inlineCode",{parentName:"p"},"druid")," for standard ",(0,l.kt)("a",{parentName:"p",href:"/docs/querying/datasource#table"},"Druid Table datasources"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"lookup")," for ",(0,l.kt)("a",{parentName:"p",href:"/docs/querying/datasource#lookup"},"Lookups"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"sys")," for the virtual ",(0,l.kt)("a",{parentName:"p",href:"#system-schema"},"System metadata tables"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"INFORMATION_SCHEMA")," for these virtual tables. Tables are allowed to have the same name across different schemas, so the schema may be included in an SQL statement to distinguish them, e.g. ",(0,l.kt)("inlineCode",{parentName:"p"},"lookup.table")," vs ",(0,l.kt)("inlineCode",{parentName:"p"},"druid.table"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Column"),(0,l.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CATALOG_NAME"),(0,l.kt)("td",{parentName:"tr",align:null},"Always set as ",(0,l.kt)("inlineCode",{parentName:"td"},"druid"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SCHEMA_NAME"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"druid"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"lookup"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"sys"),", or ",(0,l.kt)("inlineCode",{parentName:"td"},"INFORMATION_SCHEMA"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SCHEMA_OWNER"),(0,l.kt)("td",{parentName:"tr",align:null},"Unused")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"DEFAULT_CHARACTER_SET_CATALOG"),(0,l.kt)("td",{parentName:"tr",align:null},"Unused")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"DEFAULT_CHARACTER_SET_SCHEMA"),(0,l.kt)("td",{parentName:"tr",align:null},"Unused")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"DEFAULT_CHARACTER_SET_NAME"),(0,l.kt)("td",{parentName:"tr",align:null},"Unused")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SQL_PATH"),(0,l.kt)("td",{parentName:"tr",align:null},"Unused")))),(0,l.kt)("h3",{id:"tables-table"},"TABLES table"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"INFORMATION_SCHEMA.TABLES")," provides a list of all known tables and schemas."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Column"),(0,l.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TABLE_CATALOG"),(0,l.kt)("td",{parentName:"tr",align:null},"Always set as ",(0,l.kt)("inlineCode",{parentName:"td"},"druid"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TABLE_SCHEMA"),(0,l.kt)("td",{parentName:"tr",align:null},"The 'schema' which the table falls under, see ",(0,l.kt)("a",{parentName:"td",href:"#schemata-table"},"SCHEMATA table for details"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TABLE_NAME"),(0,l.kt)("td",{parentName:"tr",align:null},"Table name. For the ",(0,l.kt)("inlineCode",{parentName:"td"},"druid")," schema, this is the ",(0,l.kt)("inlineCode",{parentName:"td"},"dataSource"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TABLE_TYPE"),(0,l.kt)("td",{parentName:"tr",align:null},'"TABLE" or "SYSTEM_TABLE"')),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"IS_JOINABLE"),(0,l.kt)("td",{parentName:"tr",align:null},"If a table is directly joinable if on the right hand side of a ",(0,l.kt)("inlineCode",{parentName:"td"},"JOIN")," statement, without performing a subquery, this value will be set to ",(0,l.kt)("inlineCode",{parentName:"td"},"YES"),", otherwise ",(0,l.kt)("inlineCode",{parentName:"td"},"NO"),". Lookups are always joinable because they are globally distributed among Druid query processing nodes, but Druid datasources are not, and will use a less efficient subquery join.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"IS_BROADCAST"),(0,l.kt)("td",{parentName:"tr",align:null},"If a table is 'broadcast' and distributed among all Druid query processing nodes, this value will be set to ",(0,l.kt)("inlineCode",{parentName:"td"},"YES"),", such as lookups and Druid datasources which have a 'broadcast' load rule, else ",(0,l.kt)("inlineCode",{parentName:"td"},"NO"),".")))),(0,l.kt)("h3",{id:"columns-table"},"COLUMNS table"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"INFORMATION_SCHEMA.COLUMNS")," provides a list of all known columns across all tables and schema."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Column"),(0,l.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TABLE_CATALOG"),(0,l.kt)("td",{parentName:"tr",align:null},"Always set as ",(0,l.kt)("inlineCode",{parentName:"td"},"druid"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TABLE_SCHEMA"),(0,l.kt)("td",{parentName:"tr",align:null},"The 'schema' which the table column falls under, see ",(0,l.kt)("a",{parentName:"td",href:"#schemata-table"},"SCHEMATA table for details"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"TABLE_NAME"),(0,l.kt)("td",{parentName:"tr",align:null},"The 'table' which the column belongs to, see ",(0,l.kt)("a",{parentName:"td",href:"#tables-table"},"TABLES table for details"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"COLUMN_NAME"),(0,l.kt)("td",{parentName:"tr",align:null},"The column name")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ORDINAL_POSITION"),(0,l.kt)("td",{parentName:"tr",align:null},"The order in which the column is stored in a table")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"COLUMN_DEFAULT"),(0,l.kt)("td",{parentName:"tr",align:null},"Unused")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"IS_NULLABLE"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"DATA_TYPE"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CHARACTER_MAXIMUM_LENGTH"),(0,l.kt)("td",{parentName:"tr",align:null},"Unused")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CHARACTER_OCTET_LENGTH"),(0,l.kt)("td",{parentName:"tr",align:null},"Unused")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NUMERIC_PRECISION"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NUMERIC_PRECISION_RADIX"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"NUMERIC_SCALE"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"DATETIME_PRECISION"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"CHARACTER_SET_NAME"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"COLLATION_NAME"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"JDBC_TYPE"),(0,l.kt)("td",{parentName:"tr",align:null},"Type code from java.sql.Types (Druid extension)")))),(0,l.kt)("p",null,"For example, this query returns ",(0,l.kt)("a",{parentName:"p",href:"/docs/querying/sql-data-types"},"data type")," information for columns in the ",(0,l.kt)("inlineCode",{parentName:"p"},"foo")," table:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT "ORDINAL_POSITION", "COLUMN_NAME", "IS_NULLABLE", "DATA_TYPE", "JDBC_TYPE"\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE "TABLE_NAME" = \'foo\'\n')),(0,l.kt)("h2",{id:"system-schema"},"SYSTEM SCHEMA"),(0,l.kt)("p",null,'The "sys" schema provides visibility into Druid segments, servers and tasks.'),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'Note: "sys" tables do not currently support Druid-specific functions like ',(0,l.kt)("inlineCode",{parentName:"p"},"TIME_PARSE")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"APPROX_QUANTILE_DS"),". Only standard SQL functions can be used.")),(0,l.kt)("h3",{id:"segments-table"},"SEGMENTS table"),(0,l.kt)("p",null,"Segments table provides details on all Druid segments, whether they are published yet or not."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Column"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"segment_id"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Unique segment identifier")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datasource"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Name of datasource")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"start"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Interval start time (in ISO 8601 format)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"end"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Interval end time (in ISO 8601 format)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"size"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Size of segment in bytes")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"version"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Version string (generally an ISO8601 timestamp corresponding to when the segment set was first started). Higher version means the more recently created segment. Version comparing is based on string comparison.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"partition_num"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Partition number (an integer, unique within a datasource+interval+version; may not necessarily be contiguous)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"num_replicas"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of replicas of this segment currently being served")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"num_rows"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of rows in this segment, or zero if the number of rows is not known.",(0,l.kt)("br",null),(0,l.kt)("br",null),"This row count is gathered by the Broker in the background. It will be zero if the Broker has not gathered a row count for this segment yet. For segments ingested from streams, the reported row count may lag behind the result of a ",(0,l.kt)("inlineCode",{parentName:"td"},"count(*)")," query because the cached ",(0,l.kt)("inlineCode",{parentName:"td"},"num_rows")," on the Broker may be out of date. This will settle shortly after new rows stop being written to that particular segment.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"is_active"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"True for segments that represent the latest state of a datasource.",(0,l.kt)("br",null),(0,l.kt)("br",null),"Equivalent to ",(0,l.kt)("inlineCode",{parentName:"td"},"(is_published = 1 AND is_overshadowed = 0) OR is_realtime = 1"),". In steady state, when no ingestion or data management operations are happening, ",(0,l.kt)("inlineCode",{parentName:"td"},"is_active")," will be equivalent to ",(0,l.kt)("inlineCode",{parentName:"td"},"is_available"),". However, they may differ from each other when ingestion or data management operations have executed recently. In these cases, Druid will load and unload segments appropriately to bring actual availability in line with the expected state given by ",(0,l.kt)("inlineCode",{parentName:"td"},"is_active"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"is_published"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Boolean represented as long type where 1 = true, 0 = false. 1 if this segment has been published to the metadata store and is marked as used. See the ",(0,l.kt)("a",{parentName:"td",href:"/docs/design/architecture#segment-lifecycle"},"segment lifecycle documentation")," for more details.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"is_available"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Boolean represented as long type where 1 = true, 0 = false. 1 if this segment is currently being served by any data serving process, like a Historical or a realtime ingestion task. See the ",(0,l.kt)("a",{parentName:"td",href:"/docs/design/architecture#segment-lifecycle"},"segment lifecycle documentation")," for more details.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"is_realtime"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Boolean represented as long type where 1 = true, 0 = false. 1 if this segment is ",(0,l.kt)("em",{parentName:"td"},"only")," served by realtime tasks, and 0 if any Historical process is serving this segment.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"is_overshadowed"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Boolean represented as long type where 1 = true, 0 = false. 1 if this segment is published and is ",(0,l.kt)("em",{parentName:"td"},"fully")," overshadowed by some other published segments. Currently, ",(0,l.kt)("inlineCode",{parentName:"td"},"is_overshadowed"),' is always 0 for unpublished segments, although this may change in the future. You can filter for segments that "should be published" by filtering for ',(0,l.kt)("inlineCode",{parentName:"td"},"is_published = 1 AND is_overshadowed = 0"),". Segments can briefly be both published and overshadowed if they were recently replaced, but have not been unpublished yet. See the ",(0,l.kt)("a",{parentName:"td",href:"/docs/design/architecture#segment-lifecycle"},"segment lifecycle documentation")," for more details.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"shard_spec"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"JSON-serialized form of the segment ",(0,l.kt)("inlineCode",{parentName:"td"},"ShardSpec"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dimensions"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"JSON-serialized form of the segment dimensions")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"metrics"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"JSON-serialized form of the segment metrics")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"last_compaction_state"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"JSON-serialized form of the compaction task's config (compaction task which created this segment). May be null if segment was not created by compaction task.")))),(0,l.kt)("p",null,'For example, to retrieve all currently active segments for datasource "wikipedia", use the query:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM sys.segments\nWHERE datasource = 'wikipedia'\nAND is_active = 1\n")),(0,l.kt)("p",null,"Another example to retrieve segments total_size, avg_size, avg_num_rows and num_segments per datasource:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT\n    datasource,\n    SUM("size") AS total_size,\n    CASE WHEN SUM("size") = 0 THEN 0 ELSE SUM("size") / (COUNT(*) FILTER(WHERE "size" > 0)) END AS avg_size,\n    CASE WHEN SUM(num_rows) = 0 THEN 0 ELSE SUM("num_rows") / (COUNT(*) FILTER(WHERE num_rows > 0)) END AS avg_num_rows,\n    COUNT(*) AS num_segments\nFROM sys.segments\nWHERE is_active = 1\nGROUP BY 1\nORDER BY 2 DESC\n')),(0,l.kt)("p",null,"This query goes a step further and shows the overall profile of available, non-realtime segments across buckets of 1 million rows each for the ",(0,l.kt)("inlineCode",{parentName:"p"},"foo")," datasource:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT ABS("num_rows" /  1000000) as "bucket",\n  COUNT(*) as segments,\n  SUM("size") / 1048576 as totalSizeMiB,\n  MIN("size") / 1048576 as minSizeMiB,\n  AVG("size") / 1048576 as averageSizeMiB,\n  MAX("size") / 1048576 as maxSizeMiB,\n  SUM("num_rows") as totalRows,\n  MIN("num_rows") as minRows,\n  AVG("num_rows") as averageRows,\n  MAX("num_rows") as maxRows,\n  (AVG("size") / AVG("num_rows"))  as avgRowSizeB\nFROM sys.segments\nWHERE is_available = 1 AND is_realtime = 0 AND "datasource" = `foo`\nGROUP BY 1\nORDER BY 1\n')),(0,l.kt)("p",null,"If you want to retrieve segment that was compacted (ANY compaction):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM sys.segments WHERE is_active = 1 AND last_compaction_state IS NOT NULL\n")),(0,l.kt)("p",null,"or if you want to retrieve segment that was compacted only by a particular compaction spec (such as that of the auto compaction):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM sys.segments WHERE is_active = 1 AND last_compaction_state = 'CompactionState{partitionsSpec=DynamicPartitionsSpec{maxRowsPerSegment=5000000, maxTotalRows=9223372036854775807}, indexSpec={bitmap={type=roaring, compressRunOnSerialization=true}, dimensionCompression=lz4, metricCompression=lz4, longEncoding=longs, segmentLoader=null}}'\n")),(0,l.kt)("h3",{id:"servers-table"},"SERVERS table"),(0,l.kt)("p",null,"Servers table lists all discovered servers in the cluster."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Column"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"server"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Server name in the form host:port")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"host"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Hostname of the server")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"plaintext_port"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Unsecured port of the server, or -1 if plaintext traffic is disabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tls_port"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"TLS port of the server, or -1 if TLS is disabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"server_type"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Type of Druid service. Possible values include: COORDINATOR, OVERLORD,  BROKER, ROUTER, HISTORICAL, MIDDLE_MANAGER or PEON.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tier"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Distribution tier see ",(0,l.kt)("a",{parentName:"td",href:"/docs/configuration/#historical-general-configuration"},"druid.server.tier"),". Only valid for HISTORICAL type, for other types it's null")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"current_size"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Current size of segments in bytes on this server. Only valid for HISTORICAL type, for other types it's 0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"max_size"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Max size in bytes this server recommends to assign to segments see ",(0,l.kt)("a",{parentName:"td",href:"/docs/configuration/#historical-general-configuration"},"druid.server.maxSize"),". Only valid for HISTORICAL type, for other types it's 0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"is_leader"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"1 if the server is currently the 'leader' (for services which have the concept of leadership), otherwise 0 if the server is not the leader, or the default long value (0 or null depending on ",(0,l.kt)("inlineCode",{parentName:"td"},"druid.generic.useDefaultValueForNull"),") if the server type does not have the concept of leadership")))),(0,l.kt)("p",null,"To retrieve information about all servers, use the query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM sys.servers;\n")),(0,l.kt)("h3",{id:"server_segments-table"},"SERVER_SEGMENTS table"),(0,l.kt)("p",null,"SERVER_SEGMENTS is used to join servers with segments table"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Column"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"server"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Server name in format host:port (Primary key of ",(0,l.kt)("a",{parentName:"td",href:"#servers-table"},"servers table"),")")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"segment_id"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Segment identifier (Primary key of ",(0,l.kt)("a",{parentName:"td",href:"#segments-table"},"segments table"),")")))),(0,l.kt)("p",null,'JOIN between "servers" and "segments" can be used to query the number of segments for a specific datasource,\ngrouped by server, example query:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT count(segments.segment_id) as num_segments from sys.segments as segments\nINNER JOIN sys.server_segments as server_segments\nON segments.segment_id  = server_segments.segment_id\nINNER JOIN sys.servers as servers\nON servers.server = server_segments.server\nWHERE segments.datasource = 'wikipedia'\nGROUP BY servers.server;\n")),(0,l.kt)("h3",{id:"tasks-table"},"TASKS table"),(0,l.kt)("p",null,"The tasks table provides information about active and recently-completed indexing tasks. For more information\ncheck out the documentation for ",(0,l.kt)("a",{parentName:"p",href:"/docs/ingestion/tasks"},"ingestion tasks"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Column"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"task_id"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Unique task identifier")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"group_id"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Task group ID for this task, the value depends on the task ",(0,l.kt)("inlineCode",{parentName:"td"},"type"),". For example, for native index tasks, it's same as ",(0,l.kt)("inlineCode",{parentName:"td"},"task_id"),", for sub tasks, this value is the parent task's ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"type"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},'Task type, for example this value is "index" for indexing tasks. See ',(0,l.kt)("a",{parentName:"td",href:"/docs/ingestion/tasks"},"tasks-overview"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"datasource"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Datasource name being indexed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"created_time"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Timestamp in ISO8601 format corresponding to when the ingestion task was created. Note that this value is populated for completed and waiting tasks. For running and pending tasks this value is set to 1970-01-01T00:00:00Z")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"queue_insertion_time"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Timestamp in ISO8601 format corresponding to when this task was added to the queue on the Overlord")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"status"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Status of a task can be RUNNING, FAILED, SUCCESS")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"runner_status"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Runner status of a completed task would be NONE, for in-progress tasks this can be RUNNING, WAITING, PENDING")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"duration"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Time it took to finish the task in milliseconds, this value is present only for completed tasks")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"location"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Server name where this task is running in the format host:port, this information is present only for RUNNING tasks")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"host"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Hostname of the server where task is running")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"plaintext_port"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Unsecured port of the server, or -1 if plaintext traffic is disabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"tls_port"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"TLS port of the server, or -1 if TLS is disabled")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"error_msg"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Detailed error message in case of FAILED tasks")))),(0,l.kt)("p",null,"For example, to retrieve tasks information filtered by status, use the query"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM sys.tasks WHERE status='FAILED';\n")),(0,l.kt)("h3",{id:"supervisors-table"},"SUPERVISORS table"),(0,l.kt)("p",null,"The supervisors table provides information about supervisors."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Column"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"supervisor_id"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Supervisor task identifier")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"state"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Basic state of the supervisor. Available states: ",(0,l.kt)("inlineCode",{parentName:"td"},"UNHEALTHY_SUPERVISOR"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"UNHEALTHY_TASKS"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"PENDING"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"RUNNING"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"SUSPENDED"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"STOPPING"),". Check ",(0,l.kt)("a",{parentName:"td",href:"/docs/development/extensions-core/kafka-supervisor-operations"},"Kafka Docs")," for details.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"detailed_state"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Supervisor specific state. (See documentation of the specific supervisor for details, e.g. ",(0,l.kt)("a",{parentName:"td",href:"/docs/development/extensions-core/kafka-ingestion"},"Kafka")," or ",(0,l.kt)("a",{parentName:"td",href:"/docs/development/extensions-core/kinesis-ingestion"},"Kinesis"),")")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"healthy"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Boolean represented as long type where 1 = true, 0 = false. 1 indicates a healthy supervisor")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"type"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Type of supervisor, e.g. ",(0,l.kt)("inlineCode",{parentName:"td"},"kafka"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"kinesis")," or ",(0,l.kt)("inlineCode",{parentName:"td"},"materialized_view"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"source"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"Source of the supervisor, e.g. Kafka topic or Kinesis stream")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"suspended"),(0,l.kt)("td",{parentName:"tr",align:null},"LONG"),(0,l.kt)("td",{parentName:"tr",align:null},"Boolean represented as long type where 1 = true, 0 = false. 1 indicates supervisor is in suspended state")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"spec"),(0,l.kt)("td",{parentName:"tr",align:null},"STRING"),(0,l.kt)("td",{parentName:"tr",align:null},"JSON-serialized supervisor spec")))),(0,l.kt)("p",null,"For example, to retrieve supervisor tasks information filtered by health status, use the query"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM sys.supervisors WHERE healthy=0;\n")))}N.isMDXComponent=!0}}]);