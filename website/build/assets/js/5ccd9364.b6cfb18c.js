"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8868],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=u(n),m=o,h=p["".concat(l,".").concat(m)]||p[m]||c[m]||r;return n?i.createElement(h,a(a({ref:t},d),{},{components:n})):i.createElement(h,a({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,a[1]=s;for(var u=2;u<r;u++)a[u]=n[u];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9934:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>u,toc:()=>p});var i=n(7462),o=n(3366),r=(n(7294),n(3905)),a=["components"],s={id:"basic-cluster-tuning",title:"Basic cluster tuning"},l=void 0,u={unversionedId:"operations/basic-cluster-tuning",id:"operations/basic-cluster-tuning",title:"Basic cluster tuning",description:"\x3c!--",source:"@site/../docs/operations/basic-cluster-tuning.md",sourceDirName:"operations",slug:"/operations/basic-cluster-tuning",permalink:"/docs/operations/basic-cluster-tuning",draft:!1,editUrl:"https://github.com/apache/druid/edit/master/docs/../docs/operations/basic-cluster-tuning.md",tags:[],version:"current",lastUpdatedBy:"Gian Merlino",lastUpdatedAt:1663390691,formattedLastUpdatedAt:"Sep 17, 2022",frontMatter:{id:"basic-cluster-tuning",title:"Basic cluster tuning"},sidebar:"docs",previous:{title:"TLS support",permalink:"/docs/operations/tls-support"},next:{title:"Segment size optimization",permalink:"/docs/operations/segment-optimization"}},d={},p=[{value:"Process-specific guidelines",id:"process-specific-guidelines",level:2},{value:"Historical",id:"historical",level:3},{value:"Heap sizing",id:"heap-sizing",level:4},{value:"Lookups",id:"lookups",level:5},{value:"Processing Threads and Buffers",id:"processing-threads-and-buffers",level:4},{value:"Direct Memory Sizing",id:"direct-memory-sizing",level:4},{value:"Connection pool sizing",id:"connection-pool-sizing",level:4},{value:"Segment Cache Size",id:"segment-cache-size",level:4},{value:"Number of Historicals",id:"number-of-historicals",level:4},{value:"SSD storage",id:"ssd-storage",level:4},{value:"Total memory usage",id:"total-memory-usage",level:4},{value:"Segment sizes matter",id:"segment-sizes-matter",level:4},{value:"Broker",id:"broker",level:3},{value:"Heap sizing",id:"heap-sizing-1",level:4},{value:"Direct memory sizing",id:"direct-memory-sizing-1",level:4},{value:"Connection pool sizing",id:"connection-pool-sizing-1",level:4},{value:"Broker backpressure",id:"broker-backpressure",level:4},{value:"Number of brokers",id:"number-of-brokers",level:4},{value:"Total memory usage",id:"total-memory-usage-1",level:4},{value:"MiddleManager",id:"middlemanager",level:3},{value:"MiddleManager heap sizing",id:"middlemanager-heap-sizing",level:4},{value:"SSD storage",id:"ssd-storage-1",level:4},{value:"Task Count",id:"task-count",level:4},{value:"Task configurations",id:"task-configurations",level:4},{value:"Task heap sizing",id:"task-heap-sizing",level:5},{value:"Lookups",id:"lookups-1",level:6},{value:"Task processing threads and buffers",id:"task-processing-threads-and-buffers",level:5},{value:"Direct memory sizing",id:"direct-memory-sizing-2",level:5},{value:"Connection pool sizing",id:"connection-pool-sizing-2",level:5},{value:"Total memory usage",id:"total-memory-usage-2",level:4},{value:"Configuration guidelines for specific ingestion types",id:"configuration-guidelines-for-specific-ingestion-types",level:5},{value:"Kafka/Kinesis ingestion",id:"kafkakinesis-ingestion",level:6},{value:"Hadoop ingestion",id:"hadoop-ingestion",level:6},{value:"Parallel native ingestion",id:"parallel-native-ingestion",level:6},{value:"Coordinator",id:"coordinator",level:3},{value:"Dynamic Configuration",id:"dynamic-configuration",level:4},{value:"Overlord",id:"overlord",level:3},{value:"Router",id:"router",level:3},{value:"Guidelines for processing threads and buffers",id:"guidelines-for-processing-threads-and-buffers",level:2},{value:"Processing threads",id:"processing-threads",level:3},{value:"Processing buffers",id:"processing-buffers",level:3},{value:"GroupBy merging buffers",id:"groupby-merging-buffers",level:3},{value:"Connection pool guidelines",id:"connection-pool-guidelines",level:2},{value:"Sizing the connection pool for queries",id:"sizing-the-connection-pool-for-queries",level:3},{value:"Per-segment direct memory buffers",id:"per-segment-direct-memory-buffers",level:2},{value:"Segment decompression",id:"segment-decompression",level:3},{value:"Segment merging",id:"segment-merging",level:3},{value:"General recommendations",id:"general-recommendations",level:2},{value:"JVM tuning",id:"jvm-tuning",level:3},{value:"Garbage Collection",id:"garbage-collection",level:4},{value:"Other generally useful JVM flags",id:"other-generally-useful-jvm-flags",level:4},{value:"Use UTC timezone",id:"use-utc-timezone",level:3},{value:"System configuration",id:"system-configuration",level:3},{value:"SSDs",id:"ssds",level:4},{value:"JBOD vs RAID",id:"jbod-vs-raid",level:4},{value:"Swap space",id:"swap-space",level:4},{value:"Linux limits",id:"linux-limits",level:4},{value:"ulimit",id:"ulimit",level:5},{value:"max_map_count",id:"max_map_count",level:5}],c={toc:p};function m(e){var t=e.components,n=(0,o.Z)(e,a);return(0,r.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This document provides basic guidelines for configuration properties and cluster architecture considerations related to performance tuning of an Apache Druid deployment."),(0,r.kt)("p",null,"Please note that this document provides general guidelines and rules-of-thumb: these are not absolute, universal rules for cluster tuning, and this introductory guide is not an exhaustive description of all Druid tuning properties, which are described in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/configuration/"},"configuration reference"),"."),(0,r.kt)("p",null,"If you have questions on tuning Druid for specific use cases, or questions on configuration properties not covered in this guide, please ask the ",(0,r.kt)("a",{parentName:"p",href:"https://druid.apache.org/community/"},"Druid user mailing list or other community channels"),"."),(0,r.kt)("h2",{id:"process-specific-guidelines"},"Process-specific guidelines"),(0,r.kt)("h3",{id:"historical"},"Historical"),(0,r.kt)("h4",{id:"heap-sizing"},"Heap sizing"),(0,r.kt)("p",null,"The biggest contributions to heap usage on Historicals are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Partial unmerged query results from segments"),(0,r.kt)("li",{parentName:"ul"},"The stored maps for ",(0,r.kt)("a",{parentName:"li",href:"/docs/querying/lookups"},"lookups"),".")),(0,r.kt)("p",null,"A general rule-of-thumb for sizing the Historical heap is ",(0,r.kt)("inlineCode",{parentName:"p"},"(0.5GiB * number of CPU cores)"),", with an upper limit of ~24GiB."),(0,r.kt)("p",null,"This rule-of-thumb scales using the number of CPU cores as a convenient proxy for hardware size and level of concurrency (note: this formula is not a hard rule for sizing Historical heaps)."),(0,r.kt)("p",null,"Having a heap that is too large can result in excessively long GC collection pauses, the ~24GiB upper limit is imposed to avoid this."),(0,r.kt)("p",null,"If caching is enabled on Historicals, the cache is stored on heap, sized by ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.cache.sizeInBytes"),"."),(0,r.kt)("p",null,"Running out of heap on the Historicals can indicate misconfiguration or usage patterns that are overloading the cluster."),(0,r.kt)("h5",{id:"lookups"},"Lookups"),(0,r.kt)("p",null,"If you are using lookups, calculate the total size of the lookup maps being loaded."),(0,r.kt)("p",null,"Druid performs an atomic swap when updating lookup maps (both the old map and the new map will exist in heap during the swap), so the maximum potential heap usage from lookup maps will be (2 * total size of all loaded lookups)."),(0,r.kt)("p",null,"Be sure to add ",(0,r.kt)("inlineCode",{parentName:"p"},"(2 * total size of all loaded lookups)")," to your heap size in addition to the ",(0,r.kt)("inlineCode",{parentName:"p"},"(0.5GiB * number of CPU cores)")," guideline."),(0,r.kt)("h4",{id:"processing-threads-and-buffers"},"Processing Threads and Buffers"),(0,r.kt)("p",null,"Please see the ",(0,r.kt)("a",{parentName:"p",href:"#processing-threads-buffers"},"General Guidelines for Processing Threads and Buffers")," section for an overview of processing thread/buffer configuration."),(0,r.kt)("p",null,"On Historicals:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"druid.processing.numThreads")," should generally be set to ",(0,r.kt)("inlineCode",{parentName:"li"},"(number of cores - 1)"),": a smaller value can result in CPU underutilization, while going over the number of cores can result in unnecessary CPU contention."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"druid.processing.buffer.sizeBytes")," can be set to 500MiB."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"druid.processing.numMergeBuffers"),", a 1:4 ratio of  merge buffers to processing threads is a reasonable choice for general use.")),(0,r.kt)("h4",{id:"direct-memory-sizing"},"Direct Memory Sizing"),(0,r.kt)("p",null,"The processing and merge buffers described above are direct memory buffers."),(0,r.kt)("p",null,"When a historical processes a query, it must open a set of segments for reading. This also requires some direct memory space, described in ",(0,r.kt)("a",{parentName:"p",href:"#segment-decompression"},"segment decompression buffers"),"."),(0,r.kt)("p",null,"A formula for estimating direct memory usage follows:"),(0,r.kt)("p",null,"(",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.numThreads")," + ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.numMergeBuffers")," + 1) * ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.buffer.sizeBytes")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"+ 1")," factor is a fuzzy estimate meant to account for the segment decompression buffers."),(0,r.kt)("h4",{id:"connection-pool-sizing"},"Connection pool sizing"),(0,r.kt)("p",null,"Please see the ",(0,r.kt)("a",{parentName:"p",href:"#connection-pool"},"General Connection Pool Guidelines")," section for an overview of connection pool configuration."),(0,r.kt)("p",null,"For Historicals, ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.server.http.numThreads")," should be set to a value slightly higher than the sum of ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," across all the Brokers in the cluster."),(0,r.kt)("p",null,"Tuning the cluster so that each Historical can accept 50 queries and 10 non-queries is a reasonable starting point."),(0,r.kt)("h4",{id:"segment-cache-size"},"Segment Cache Size"),(0,r.kt)("p",null,"For better query performance, do not allocate segment data to a Historical in excess of the system free memory.  When ",(0,r.kt)("inlineCode",{parentName:"p"},"free system memory")," is greater than or equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.segmentCache.locations"),", the more segment data the Historical can be held in the memory-mapped segment cache."),(0,r.kt)("p",null,"Druid uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.segmentCache.locations")," to calculate the total segment data size assigned to a Historical. For some rarer use cases, you can override this behavior with ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.server.maxSize")," property."),(0,r.kt)("h4",{id:"number-of-historicals"},"Number of Historicals"),(0,r.kt)("p",null,"The number of Historicals needed in a cluster depends on how much data the cluster has. For good performance, you will want enough Historicals such that each Historical has a good (",(0,r.kt)("inlineCode",{parentName:"p"},"free system memory")," / total size of all ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.segmentCache.locations"),") ratio, as described in the segment cache size section above."),(0,r.kt)("p",null,"Having a smaller number of big servers is generally better than having a large number of small servers, as long as you have enough fault tolerance for your use case."),(0,r.kt)("h4",{id:"ssd-storage"},"SSD storage"),(0,r.kt)("p",null,"We recommend using SSDs for storage on the Historicals, as they handle segment data stored on disk."),(0,r.kt)("h4",{id:"total-memory-usage"},"Total memory usage"),(0,r.kt)("p",null,"To estimate total memory usage of the Historical under these guidelines:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Heap: ",(0,r.kt)("inlineCode",{parentName:"li"},"(0.5GiB * number of CPU cores) + (2 * total size of lookup maps) + druid.cache.sizeInBytes")),(0,r.kt)("li",{parentName:"ul"},"Direct Memory: ",(0,r.kt)("inlineCode",{parentName:"li"},"(druid.processing.numThreads + druid.processing.numMergeBuffers + 1) * druid.processing.buffer.sizeBytes"))),(0,r.kt)("p",null,"The Historical will use any available free system memory (i.e., memory not used by the Historical JVM and heap/direct memory buffers or other processes on the system) for memory-mapping of segments on disk. For better query performance, you will want to ensure a good (",(0,r.kt)("inlineCode",{parentName:"p"},"free system memory")," / total size of all ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.segmentCache.locations"),") ratio so that a greater proportion of segments can be kept in memory."),(0,r.kt)("h4",{id:"segment-sizes-matter"},"Segment sizes matter"),(0,r.kt)("p",null,"Be sure to check out ",(0,r.kt)("a",{parentName:"p",href:"/docs/operations/segment-optimization"},"segment size optimization")," to help tune your Historical processes for maximum performance."),(0,r.kt)("h3",{id:"broker"},"Broker"),(0,r.kt)("h4",{id:"heap-sizing-1"},"Heap sizing"),(0,r.kt)("p",null,"The biggest contributions to heap usage on Brokers are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Partial unmerged query results from Historicals and Tasks"),(0,r.kt)("li",{parentName:"ul"},"The segment timeline: this consists of location information (which Historical/Task is serving a segment) for all currently ",(0,r.kt)("a",{parentName:"li",href:"/docs/design/architecture#segment-lifecycle"},"available")," segments."),(0,r.kt)("li",{parentName:"ul"},"Cached segment metadata: this consists of metadata, such as per-segment schemas, for all currently available segments.")),(0,r.kt)("p",null,"The Broker heap requirements scale based on the number of segments in the cluster, and the total data size of the segments."),(0,r.kt)("p",null,"The heap size will vary based on data size and usage patterns, but 4GiB to 8GiB is a good starting point for a small or medium cluster (~15 servers or less). For a rough estimate of memory requirements on the high end, very large clusters with a node count on the order of ~100 nodes may need Broker heaps of 30GiB-60GiB."),(0,r.kt)("p",null,"If caching is enabled on the Broker, the cache is stored on heap, sized by ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.cache.sizeInBytes"),"."),(0,r.kt)("h4",{id:"direct-memory-sizing-1"},"Direct memory sizing"),(0,r.kt)("p",null,"On the Broker, the amount of direct memory needed depends on how many merge buffers (used for merging GroupBys) are configured. The Broker does not generally need processing threads or processing buffers, as query results are merged on-heap in the HTTP connection threads instead."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"druid.processing.buffer.sizeBytes")," can be set to 500MiB."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"druid.processing.numMergeBuffers"),": set this to the same value as on Historicals or a bit higher")),(0,r.kt)("h4",{id:"connection-pool-sizing-1"},"Connection pool sizing"),(0,r.kt)("p",null,"Please see the ",(0,r.kt)("a",{parentName:"p",href:"#connection-pool"},"General Connection Pool Guidelines")," section for an overview of connection pool configuration."),(0,r.kt)("p",null,"On the Brokers, please ensure that the sum of ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," across all the Brokers is slightly lower than the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.server.http.numThreads")," on your Historicals and Tasks."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"druid.server.http.numThreads")," on the Broker should be set to a value slightly higher than ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," on the same Broker."),(0,r.kt)("p",null,"Tuning the cluster so that each Historical can accept 50 queries and 10 non-queries, adjusting the Brokers accordingly, is a reasonable starting point."),(0,r.kt)("h4",{id:"broker-backpressure"},"Broker backpressure"),(0,r.kt)("p",null,"When retrieving query results from Historical processes or Tasks, the Broker can optionally specify a maximum buffer size for queued, unread data, and exert backpressure on the channel to the Historical or Tasks when limit is reached (causing writes to the channel to block on the Historical/Task side until the Broker is able to drain some data from the channel)."),(0,r.kt)("p",null,"This buffer size is controlled by the ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.maxQueuedBytes")," setting."),(0,r.kt)("p",null,"The limit is divided across the number of Historicals/Tasks that a query would hit: suppose I have ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.maxQueuedBytes")," set to 5MiB, and the Broker receives a query that needs to be fanned out to 2 Historicals. Each per-historical channel would get a 2.5MiB buffer in this case."),(0,r.kt)("p",null,"You can generally set this to a value of approximately ",(0,r.kt)("inlineCode",{parentName:"p"},"2MiB * number of Historicals"),". As your cluster scales up with more Historicals and Tasks, consider increasing this buffer size and increasing the Broker heap accordingly."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the buffer is too small, this can lead to inefficient queries due to the buffer filling up rapidly and stalling the channel"),(0,r.kt)("li",{parentName:"ul"},"If the buffer is too large, this puts more memory pressure on the Broker due to more queued result data in the HTTP channels.")),(0,r.kt)("h4",{id:"number-of-brokers"},"Number of brokers"),(0,r.kt)("p",null,"A 1:15 ratio of Brokers to Historicals is a reasonable starting point (this is not a hard rule)."),(0,r.kt)("p",null,"If you need Broker HA, you can deploy 2 initially and then use the 1:15 ratio guideline for additional Brokers."),(0,r.kt)("h4",{id:"total-memory-usage-1"},"Total memory usage"),(0,r.kt)("p",null,"To estimate total memory usage of the Broker under these guidelines:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Heap: allocated heap size"),(0,r.kt)("li",{parentName:"ul"},"Direct Memory: ",(0,r.kt)("inlineCode",{parentName:"li"},"(druid.processing.numMergeBuffers + 1) * druid.processing.buffer.sizeBytes"))),(0,r.kt)("h3",{id:"middlemanager"},"MiddleManager"),(0,r.kt)("p",null,"The MiddleManager is a lightweight task controller/manager that launches Task processes, which perform ingestion work."),(0,r.kt)("h4",{id:"middlemanager-heap-sizing"},"MiddleManager heap sizing"),(0,r.kt)("p",null,"The MiddleManager itself does not require much resources, you can set the heap to ~128MiB generally."),(0,r.kt)("h4",{id:"ssd-storage-1"},"SSD storage"),(0,r.kt)("p",null,"We recommend using SSDs for storage on the MiddleManagers, as the Tasks launched by MiddleManagers handle segment data stored on disk."),(0,r.kt)("h4",{id:"task-count"},"Task Count"),(0,r.kt)("p",null,"The number of tasks a MiddleManager can launch is controlled by the ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.worker.capacity")," setting."),(0,r.kt)("p",null,"The number of workers needed in your cluster depends on how many concurrent ingestion tasks you need to run for your use cases. The number of workers that can be launched on a given machine depends on the size of resources allocated per worker and available system resources."),(0,r.kt)("p",null,"You can allocate more MiddleManager machines to your cluster to add task capacity."),(0,r.kt)("h4",{id:"task-configurations"},"Task configurations"),(0,r.kt)("p",null,"The following section below describes configuration for Tasks launched by the MiddleManager. The Tasks can be queried and perform ingestion workloads, so they require more resources than the MM."),(0,r.kt)("h5",{id:"task-heap-sizing"},"Task heap sizing"),(0,r.kt)("p",null,"A 1GiB heap is usually enough for Tasks."),(0,r.kt)("h6",{id:"lookups-1"},"Lookups"),(0,r.kt)("p",null,"If you are using lookups, calculate the total size of the lookup maps being loaded."),(0,r.kt)("p",null,"Druid performs an atomic swap when updating lookup maps (both the old map and the new map will exist in heap during the swap), so the maximum potential heap usage from lookup maps will be (2 * total size of all loaded lookups)."),(0,r.kt)("p",null,"Be sure to add ",(0,r.kt)("inlineCode",{parentName:"p"},"(2 * total size of all loaded lookups)")," to your Task heap size if you are using lookups."),(0,r.kt)("h5",{id:"task-processing-threads-and-buffers"},"Task processing threads and buffers"),(0,r.kt)("p",null,"For Tasks, 1 or 2 processing threads are often enough, as the Tasks tend to hold much less queryable data than Historical processes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"druid.indexer.fork.property.druid.processing.numThreads"),": set this to 1 or 2"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"druid.indexer.fork.property.druid.processing.numMergeBuffers"),": set this to 2"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"druid.indexer.fork.property.druid.processing.buffer.sizeBytes"),": can be set to 100MiB")),(0,r.kt)("h5",{id:"direct-memory-sizing-2"},"Direct memory sizing"),(0,r.kt)("p",null,"The processing and merge buffers described above are direct memory buffers."),(0,r.kt)("p",null,"When a Task processes a query, it must open a set of segments for reading. This also requires some direct memory space, described in ",(0,r.kt)("a",{parentName:"p",href:"#segment-decompression"},"segment decompression buffers"),"."),(0,r.kt)("p",null,"An ingestion Task also needs to merge partial ingestion results, which requires direct memory space, described in ",(0,r.kt)("a",{parentName:"p",href:"#segment-merging"},"segment merging"),"."),(0,r.kt)("p",null,"A formula for estimating direct memory usage follows:"),(0,r.kt)("p",null,"(",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.numThreads")," + ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.numMergeBuffers")," + 1) * ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.buffer.sizeBytes")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"+ 1")," factor is a fuzzy estimate meant to account for the segment decompression buffers and dictionary merging buffers."),(0,r.kt)("h5",{id:"connection-pool-sizing-2"},"Connection pool sizing"),(0,r.kt)("p",null,"Please see the ",(0,r.kt)("a",{parentName:"p",href:"#connection-pool"},"General Connection Pool Guidelines")," section for an overview of connection pool configuration."),(0,r.kt)("p",null,"For Tasks, ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.server.http.numThreads")," should be set to a value slightly higher than the sum of ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," across all the Brokers in the cluster."),(0,r.kt)("p",null,"Tuning the cluster so that each Task can accept 50 queries and 10 non-queries is a reasonable starting point."),(0,r.kt)("h4",{id:"total-memory-usage-2"},"Total memory usage"),(0,r.kt)("p",null,"To estimate total memory usage of a Task under these guidelines:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Heap: ",(0,r.kt)("inlineCode",{parentName:"li"},"1GiB + (2 * total size of lookup maps)")),(0,r.kt)("li",{parentName:"ul"},"Direct Memory: ",(0,r.kt)("inlineCode",{parentName:"li"},"(druid.processing.numThreads + druid.processing.numMergeBuffers + 1) * druid.processing.buffer.sizeBytes"))),(0,r.kt)("p",null,"The total memory usage of the MiddleManager + Tasks:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"MM heap size + druid.worker.capacity * (single task memory usage)")),(0,r.kt)("h5",{id:"configuration-guidelines-for-specific-ingestion-types"},"Configuration guidelines for specific ingestion types"),(0,r.kt)("h6",{id:"kafkakinesis-ingestion"},"Kafka/Kinesis ingestion"),(0,r.kt)("p",null,"If you use the ",(0,r.kt)("a",{parentName:"p",href:"/docs/development/extensions-core/kafka-ingestion"},"Kafka Indexing Service")," or ",(0,r.kt)("a",{parentName:"p",href:"/docs/development/extensions-core/kinesis-ingestion"},"Kinesis Indexing Service"),", the number of tasks required will depend on the number of partitions and your taskCount/replica settings."),(0,r.kt)("p",null,"On top of those requirements, allocating more task slots in your cluster is a good idea, so that you have free task\nslots available for other tasks, such as ",(0,r.kt)("a",{parentName:"p",href:"/docs/data-management/compaction"},"compaction tasks"),"."),(0,r.kt)("h6",{id:"hadoop-ingestion"},"Hadoop ingestion"),(0,r.kt)("p",null,"If you are only using ",(0,r.kt)("a",{parentName:"p",href:"/docs/ingestion/hadoop"},"Hadoop-based batch ingestion")," with no other ingestion types, you can lower the amount of resources allocated per Task. Batch ingestion tasks do not need to answer queries, and the bulk of the ingestion workload will be executed on the Hadoop cluster, so the Tasks do not require much resources."),(0,r.kt)("h6",{id:"parallel-native-ingestion"},"Parallel native ingestion"),(0,r.kt)("p",null,"If you are using ",(0,r.kt)("a",{parentName:"p",href:"/docs/ingestion/native-batch"},"parallel native batch ingestion"),", allocating more available task slots is a good idea and will allow greater ingestion concurrency."),(0,r.kt)("h3",{id:"coordinator"},"Coordinator"),(0,r.kt)("p",null,"The main performance-related setting on the Coordinator is the heap size."),(0,r.kt)("p",null,"The heap requirements of the Coordinator scale with the number of servers, segments, and tasks in the cluster."),(0,r.kt)("p",null,"You can set the Coordinator heap to the same size as your Broker heap, or slightly smaller: both services have to process cluster-wide state and answer API requests about this state."),(0,r.kt)("h4",{id:"dynamic-configuration"},"Dynamic Configuration"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"percentOfSegmentsToConsiderPerMove")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The default value is 100. This means that the Coordinator will consider all segments when it is looking for a segment to move. The Coordinator makes a weighted choice, with segments on Servers with the least capacity being the most likely segments to be moved.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This weighted selection strategy means that the segments on the servers who have the most available capacity are the least likely to be chosen."),(0,r.kt)("li",{parentName:"ul"},"As the number of segments in the cluster increases, the probability of choosing the Nth segment to move decreases; where N is the last segment considered for moving."),(0,r.kt)("li",{parentName:"ul"},"An admin can use this config to skip consideration of that Nth segment."))),(0,r.kt)("li",{parentName:"ul"},"Instead of skipping a precise amount of segments, we skip a percentage of segments in the cluster.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For example, with the value set to 25, only the first 25% of segments will be considered as a segment that can be moved. This 25% of segments will come from the servers that have the least available capacity.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"In this example, each time the Coordinator looks for a segment to move, it will consider 75% less segments than it did when the configuration was 100. On clusters with hundreds of thousands of segments, this can add up to meaningful coordination time savings."))))),(0,r.kt)("li",{parentName:"ul"},"General recommendations for this configuration:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If you are not worried about the amount of time it takes your Coordinator to complete a full coordination cycle, you likely do not need to modify this config."),(0,r.kt)("li",{parentName:"ul"},"If you are frustrated with how long the Coordinator takes to run a full coordination cycle, and you have set the Coordinator dynamic config ",(0,r.kt)("inlineCode",{parentName:"li"},"maxSegmentsToMove")," to a value above 0 (the default is 5), setting this config to a non-default value can help shorten coordination time.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The recommended starting point value is 66. It represents a meaningful decrease in the percentage of segments considered while also not being too aggressive (You will consider 1/3 fewer segments per move operation with this value)."))))),(0,r.kt)("li",{parentName:"ul"},"The impact that modifying this config will have on your coordination time will be a function of how low you set the config value, the value for ",(0,r.kt)("inlineCode",{parentName:"li"},"maxSegmentsToMove")," and the total number of segments in your cluster.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If your cluster has a relatively small number of segments, or you choose to move few segments per coordination cycle, there may not be much savings to be had here.")))),(0,r.kt)("h3",{id:"overlord"},"Overlord"),(0,r.kt)("p",null,"The main performance-related setting on the Overlord is the heap size."),(0,r.kt)("p",null,"The heap requirements of the Overlord scale primarily with the number of running Tasks."),(0,r.kt)("p",null,"The Overlord tends to require less resources than the Coordinator or Broker. You can generally set the Overlord heap to a value that's 25-50% of your Coordinator heap."),(0,r.kt)("h3",{id:"router"},"Router"),(0,r.kt)("p",null,"The Router has light resource requirements, as it proxies requests to Brokers without performing much computational work itself."),(0,r.kt)("p",null,"You can assign it 256MiB heap as a starting point, growing it if needed."),(0,r.kt)("a",{name:"processing-threads-buffers"}),(0,r.kt)("h2",{id:"guidelines-for-processing-threads-and-buffers"},"Guidelines for processing threads and buffers"),(0,r.kt)("h3",{id:"processing-threads"},"Processing threads"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.numThreads")," configuration controls the size of the processing thread pool used for computing query results. The size of this pool limits how many queries can be concurrently processed."),(0,r.kt)("h3",{id:"processing-buffers"},"Processing buffers"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.buffer.sizeBytes")," is a closely related property that controls the size of the off-heap buffers allocated to the processing threads."),(0,r.kt)("p",null,"One buffer is allocated for each processing thread. A size between 500MiB and 1GiB is a reasonable choice for general use."),(0,r.kt)("p",null,"The TopN and GroupBy queries use these buffers to store intermediate computed results. As the buffer size increases, more data can be processed in a single pass."),(0,r.kt)("h3",{id:"groupby-merging-buffers"},"GroupBy merging buffers"),(0,r.kt)("p",null,"If you plan to issue GroupBy V2 queries, ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.numMergeBuffers")," is an important configuration property."),(0,r.kt)("p",null,"GroupBy V2 queries use an additional pool of off-heap buffers for merging query results. These buffers have the same size as the processing buffers described above, set by the ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.buffer.sizeBytes")," property."),(0,r.kt)("p",null,"Non-nested GroupBy V2 queries require 1 merge buffer per query, while a nested GroupBy V2 query requires 2 merge buffers (regardless of the depth of nesting)."),(0,r.kt)("p",null,"The number of merge buffers determines the number of GroupBy V2 queries that can be processed concurrently."),(0,r.kt)("a",{name:"connection-pool"}),(0,r.kt)("h2",{id:"connection-pool-guidelines"},"Connection pool guidelines"),(0,r.kt)("p",null,"Each Druid process has a configuration property for the number of HTTP connection handling threads, ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.server.http.numThreads"),"."),(0,r.kt)("p",null,"The number of HTTP server threads limits how many concurrent HTTP API requests a given process can handle."),(0,r.kt)("h3",{id:"sizing-the-connection-pool-for-queries"},"Sizing the connection pool for queries"),(0,r.kt)("p",null,"The Broker has a setting ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," that controls how many outgoing connections it can make to a given Historical or Task process."),(0,r.kt)("p",null,"These connections are used to send queries to the Historicals or Tasks, with one connection per query; the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," is effectively a limit on the number of concurrent queries that a given broker can process."),(0,r.kt)("p",null,"Suppose we have a cluster with 3 Brokers and ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," is set to 10."),(0,r.kt)("p",null,"This means that each Broker in the cluster will open up to 10 connections to each individual Historical or Task (for a total of 30 incoming query connections per Historical/Task)."),(0,r.kt)("p",null,"On the Historical/Task side, this means that ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.server.http.numThreads")," must be set to a value at least as high as the sum of ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," across all the Brokers in the cluster."),(0,r.kt)("p",null,"In practice, you will want to allocate additional server threads for non-query API requests such as status checks; adding 10 threads for those is a good general guideline. Using the example with 3 Brokers in the cluster and ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," set to 10, a value of 40 would be appropriate for ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.server.http.numThreads")," on Historicals and Tasks."),(0,r.kt)("p",null,"As a starting point, allowing for 50 concurrent queries (requests that read segment data from datasources) + 10 non-query requests (other requests like status checks) on Historicals and Tasks is reasonable (i.e., set ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.server.http.numThreads")," to 60 there), while sizing ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.broker.http.numConnections")," based on the number of Brokers in the cluster to fit within the 50 query connection limit per Historical/Task."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the connection pool across Brokers and Historicals/Tasks is too small, the cluster will be underutilized as there are too few concurrent query slots."),(0,r.kt)("li",{parentName:"ul"},"If the connection pool is too large, you may get out-of-memory errors due to excessive concurrent load, and increased resource contention."),(0,r.kt)("li",{parentName:"ul"},"The connection pool sizing matters most when you require QoS-type guarantees and use query priorities; otherwise, these settings can be more loosely configured."),(0,r.kt)("li",{parentName:"ul"},"If your cluster usage patterns are heavily biased towards a high number of small concurrent queries (where each query takes less than ~15ms), enlarging the connection pool can be a good idea."),(0,r.kt)("li",{parentName:"ul"},'The 50/10 general guideline here is a rough starting point, since different queries impose different amounts of load on the system. To size the connection pool more exactly for your cluster, you would need to know the execution times for your queries and ensure that the rate of incoming queries does not exceed your "drain" rate.')),(0,r.kt)("h2",{id:"per-segment-direct-memory-buffers"},"Per-segment direct memory buffers"),(0,r.kt)("h3",{id:"segment-decompression"},"Segment decompression"),(0,r.kt)("p",null,"When opening a segment for reading during segment merging or query processing, Druid allocates a 64KiB off-heap decompression buffer for each column being read."),(0,r.kt)("p",null,"Thus, there is additional direct memory overhead of (64KiB ",(0,r.kt)("em",{parentName:"p"}," number of columns read per segment ")," number of segments read) when reading segments."),(0,r.kt)("h3",{id:"segment-merging"},"Segment merging"),(0,r.kt)("p",null,"In addition to the segment decompression overhead described above, when a set of segments are merged during ingestion, a direct buffer is allocated for every String typed column, for every segment in the set to be merged."),(0,r.kt)("p",null,"The size of these buffers are equal to the cardinality of the String column within its segment, times 4 bytes (the buffers store integers)."),(0,r.kt)("p",null,"For example, if two segments are being merged, the first segment having a single String column with cardinality 1000, and the second segment having a String column with cardinality 500, the merge step would allocate (1000 + 500) * 4 = 6000 bytes of direct memory."),(0,r.kt)("p",null,'These buffers are used for merging the value dictionaries of the String column across segments. These "dictionary merging buffers" are independent of the "merge buffers" configured by ',(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.numMergeBuffers"),"."),(0,r.kt)("h2",{id:"general-recommendations"},"General recommendations"),(0,r.kt)("h3",{id:"jvm-tuning"},"JVM tuning"),(0,r.kt)("h4",{id:"garbage-collection"},"Garbage Collection"),(0,r.kt)("p",null,"We recommend using the G1GC garbage collector:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-XX:+UseG1GC")),(0,r.kt)("p",null,"Enabling process termination on out-of-memory errors is useful as well, since the process generally will not recover from such a state, and it's better to restart the process:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"-XX:+ExitOnOutOfMemoryError")),(0,r.kt)("h4",{id:"other-generally-useful-jvm-flags"},"Other generally useful JVM flags"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-Duser.timezone=UTC\n-Dfile.encoding=UTF-8\n-Djava.io.tmpdir=<should not be volatile tmpfs and also has good read and write speed. Strongly recommended to avoid using NFS mount>\n-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager\n-Dorg.jboss.logging.provider=slf4j\n-Dnet.spy.log.LoggerImpl=net.spy.memcached.compat.log.SLF4JLogger\n-Dlog4j.shutdownCallbackRegistry=org.apache.druid.common.config.Log4jShutdown\n-Dlog4j.shutdownHookEnabled=true\n-XX:+PrintGCDetails\n-XX:+PrintGCDateStamps\n-XX:+PrintGCTimeStamps\n-XX:+PrintGCApplicationStoppedTime\n-XX:+PrintGCApplicationConcurrentTime\n-Xloggc:/var/logs/druid/historical.gc.log\n-XX:+UseGCLogFileRotation\n-XX:NumberOfGCLogFiles=50\n-XX:GCLogFileSize=10m\n-XX:+ExitOnOutOfMemoryError\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/var/logs/druid/historical.hprof\n-XX:MaxDirectMemorySize=1g\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Please note that the flag settings above represent sample, general guidelines only. Be careful to use values appropriate\nfor your specific scenario and be sure to test any changes in staging environments.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ExitOnOutOfMemoryError")," flag is only supported starting JDK 8u92 . For older versions, ",(0,r.kt)("inlineCode",{parentName:"p"},"-XX:OnOutOfMemoryError='kill -9 %p'")," can be used."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"MaxDirectMemorySize")," restricts JVM from allocating more than specified limit, by setting it to unlimited JVM restriction is lifted and OS level memory limits would still be effective. It's still important to make sure that Druid is not configured to allocate more off-heap memory than your machine has available. Important settings here include ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.numThreads"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.numMergeBuffers"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"druid.processing.buffer.sizeBytes"),"."),(0,r.kt)("p",null,"Additionally, for large JVM heaps, here are a few Garbage Collection efficiency guidelines that have been known to help in some cases."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Mount /tmp on tmpfs. See ",(0,r.kt)("a",{parentName:"li",href:"http://www.evanjones.ca/jvm-mmap-pause.html"},"The Four Month Bug: JVM statistics cause garbage collection pauses"),"."),(0,r.kt)("li",{parentName:"ul"},"On Disk-IO intensive processes (e.g., Historical and MiddleManager), GC and Druid logs should be written to a different disk than where data is written."),(0,r.kt)("li",{parentName:"ul"},"Disable ",(0,r.kt)("a",{parentName:"li",href:"https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html"},"Transparent Huge Pages"),"."),(0,r.kt)("li",{parentName:"ul"},"Try disabling biased locking by using ",(0,r.kt)("inlineCode",{parentName:"li"},"-XX:-UseBiasedLocking")," JVM flag. See ",(0,r.kt)("a",{parentName:"li",href:"https://dzone.com/articles/logging-stop-world-pauses-jvm"},"Logging Stop-the-world Pauses in JVM"),".")),(0,r.kt)("h3",{id:"use-utc-timezone"},"Use UTC timezone"),(0,r.kt)("p",null,"We recommend using UTC timezone for all your events and across your hosts, not just for Druid, but for all data infrastructure. This can greatly mitigate potential query problems with inconsistent timezones. To query in a non-UTC timezone see ",(0,r.kt)("a",{parentName:"p",href:"/docs/querying/granularities#period-granularities"},"query granularities")),(0,r.kt)("h3",{id:"system-configuration"},"System configuration"),(0,r.kt)("h4",{id:"ssds"},"SSDs"),(0,r.kt)("p",null,"SSDs are highly recommended for Historical, MiddleManager, and Indexer processes if you are not running a cluster that is entirely in memory. SSDs can greatly mitigate the time required to page data in and out of memory."),(0,r.kt)("h4",{id:"jbod-vs-raid"},"JBOD vs RAID"),(0,r.kt)("p",null,"Historical processes store large number of segments on Disk and support specifying multiple paths for storing those. Typically, hosts have multiple disks configured with RAID which makes them look like a single disk to OS. RAID might have overheads specially if its not hardware controller based but software based. So, Historicals might get improved disk throughput with JBOD."),(0,r.kt)("h4",{id:"swap-space"},"Swap space"),(0,r.kt)("p",null,"We recommend ",(0,r.kt)("em",{parentName:"p"},"not")," using swap space for Historical, MiddleManager, and Indexer processes since due to the large number of memory mapped segment files can lead to poor and unpredictable performance."),(0,r.kt)("h4",{id:"linux-limits"},"Linux limits"),(0,r.kt)("p",null,"For Historical, MiddleManager, and Indexer processes (and for really large clusters, Broker processes), you might need to adjust some Linux system limits to account for a large number of open files, a large number of network connections, or a large number of memory mapped files."),(0,r.kt)("h5",{id:"ulimit"},"ulimit"),(0,r.kt)("p",null,"The limit on the number of open files can be set permanently by editing ",(0,r.kt)("inlineCode",{parentName:"p"},"/etc/security/limits.conf"),". This value should be substantially greater than the number of segment files that will exist on the server."),(0,r.kt)("h5",{id:"max_map_count"},"max_map_count"),(0,r.kt)("p",null,"Historical processes and to a lesser extent, MiddleManager and Indexer processes memory map segment files, so depending on the number of segments per server, ",(0,r.kt)("inlineCode",{parentName:"p"},"/proc/sys/vm/max_map_count")," might also need to be adjusted. Depending on the variant of Linux, this might be done via ",(0,r.kt)("inlineCode",{parentName:"p"},"sysctl")," by placing a file in ",(0,r.kt)("inlineCode",{parentName:"p"},"/etc/sysctl.d/")," that sets ",(0,r.kt)("inlineCode",{parentName:"p"},"vm.max_map_count"),"."))}m.isMDXComponent=!0}}]);