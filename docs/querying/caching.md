---
id: caching
title: "Query caching"
---

<!--
  ~ Licensed to the Apache Software Foundation (ASF) under one
  ~ or more contributor license agreements.  See the NOTICE file
  ~ distributed with this work for additional information
  ~ regarding copyright ownership.  The ASF licenses this file
  ~ to you under the Apache License, Version 2.0 (the
  ~ "License"); you may not use this file except in compliance
  ~ with the License.  You may obtain a copy of the License at
  ~
  ~   http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing,
  ~ software distributed under the License is distributed on an
  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  ~ KIND, either express or implied.  See the License for the
  ~ specific language governing permissions and limitations
  ~ under the License.
  -->

You can enable caching in Apache Druid to improve query times for frequently accessed data. This topic defines the different types of caching for Druid. It describes the default caching behavior and provides guidance and examples to help you hone your caching strategy.

If you're unfamiliar with Druid architecture, review the following topics before proceeding with caching:
- [Druid Design](../design/architecture.md)
- [Segments](../design/segments.md)
- [Query execution](./query-execution)

For instructions to configure caching see [Using query caching](./using-caching.md).

## Cache types

Druid supports segment caching which stores _partial results_ of a query for a specific segment, and whole-query which stores all results for a query.

### Segment caching

The primary form of caching in Druid is the segment cache. The segment cache stores query results on a per-segment basis. It is enabled on Historical services by default.

When your queries include data from segments that are mutable and undergoing real-time ingestion, use a **segment cache**. In this case Druid caches query results for immutable historical segments when possible. It re-computes results for the real-time segments at query time.

For example, you have queries that frequently include incoming data from a Kafka or Kinesis stream alongside unchanging segments. Whole-query caching is not helpful in this scenario because the new data from real-time ingestion continually invalidates the cache. Segment caching lets Druid cache results from older immutable segments and merge them with updated data.

### Whole-query caching

Segment caching requires Druid to merge the per-segment results for each query, even when the results are cached. If real-time ingestion invalidating the cache is not an issue for your queries, you can use **whole-query caching** on the Broker to increase query efficiency. For instance, whole-query caching is a good option when you have queries that include data from a batch ingestion task that runs every few hours or once a day.

## Where to enable caching

**Segment cache** is available as follows:
- On Brokers for small production clusters with less than five servers. 

     Do not use segment caches on the Broker for large production clusters. When `druid.broker.cache.populateCache` is `true` and query context parameter `populateCache` _is not_ `false`, Historicals return results on a per-segment basis without merging results locally thus negatively impacting cluster scalability.

- On Historicals, the default. Enable segment-level cache population on Historicals for larger production clusters to prevent Brokers from having to merge all query results. When you enable cache population on Historicals instead of Brokers, the Historicals merge their own local results and put less strain on the Brokers.

- On ingestion tasks in the Peon or Indexer service. Larger production clusters should enable segment-level cache population on task execution services only to prevent Brokers from having to merge all query results. When you enable cache population on task execution services instead of Brokers, the the task execution services to merge their own local results and put less strain on the brokers.

     Task executor services only support caches that store data locally. For example the `caffeine` cache. This restriction exists because the cache stores results at the level of intermediate partial segments generated by the ingestion tasks. These intermediate partial segments may not be identical across task replicas. Therefore task executor services ignore remote cache types such as `memcached`.

**Whole-query cache** is only available on Brokers.

## Performance considerations for caching

When considering a caching strategy consider the following:
- Caching enables increased concurrency on the same system, therefore leading to noticeable performance improvements for queries on Druid clusters handling throughput for concurrent, mixed workloads.

- If you are looking to improve response time for a single query or page load, you should ignore caching. In general, response time for a single task should meet performance objectives even when the cache is cold.

- To avoid returning stale results, Druid invalidates the cache the moment any underlying data changes regardless of the cache type.

- During query processing, the segment cache intercepts the query and sends the results directly to the Broker. This way the query bypasses the data server processing threads. For queries requiring minimal processing in the Broker, cached queries are very quick. If work done on the Broker causes a query bottleneck, enabling caching results in little noticeable query improvement.

- The largest performance gains from segment caching tend to apply to `topN` and time series queries. The impact is less for `groupBy` queries.  The same applies to queries with or without joins.

### Scenarios where caching does not increase query performance

Caching does not solve all types of query peformance issues. For each cache type there are scenarios where caching is likely to be of little benefit.

**Segment caching** doesn't work for TBD.

**Whole-query caching** doesn't work for the following:
- `GroupBy` v2 queries
-  queries with joins
-  queries on real-time data.

## Learn more
See the following topics for more information:
- [Using query caching](./using-caching.md) to learn how to configure and use caching.
- [Druid Design](../design/architecture.md) to learn about Druid processes.  
- [Segments](../design/segments.md) to learn how Druid stores data.
- [Query execution](./query-execution) to learn how Druid services process query statements.


