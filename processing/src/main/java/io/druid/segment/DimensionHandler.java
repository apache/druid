/*
 * Licensed to Metamarkets Group Inc. (Metamarkets) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. Metamarkets licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package io.druid.segment;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Function;
import com.metamx.common.io.smoosh.FileSmoosher;
import io.druid.query.dimension.DimensionSpec;
import io.druid.segment.column.Column;
import io.druid.segment.column.ColumnCapabilities;
import io.druid.segment.column.ValueType;
import io.druid.segment.data.IOPeon;

import java.io.File;
import java.nio.ByteBuffer;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

/**
 * Processing related interface
 *
 * A DimensionHandler is an object that encapsulates indexing, column merging/building, and querying operations
 * for a given dimension type (e.g., dict-encoded String, Long).
 *
 * These operations are handled by sub-objects created through a DimensionHandler's methods:
 *   DimensionIndexer, DimensionMerger, and DimensionColumnReader, respectively.
 *
 * Each DimensionHandler object is associated with a single dimension.
 *
 * This interface allows type-specific behavior column logic, such as choice of indexing structures and disk formats.
 * to be contained within a type-specific set of handler objects, simplifying processing classes
 * such as IncrementalIndex and IndexMerger and allowing for abstracted development of additional dimension types.
 *
 * A dimension may have two representations, an encoded representation and a full representation.
 * For example, a value for a String dimension has an integer dictionary encoding, and an actual String representation.
 *
 * @param <EncodedType> class of the encoded values
 * @param <ActualType> class of the actual values
 */
public interface DimensionHandler<EncodedType extends Comparable<EncodedType>, ActualType extends Comparable<ActualType>>
{
  /**
   * Creates a new DimensionIndexer, a per-dimension object responsible for processing ingested rows in-memory, used by the
   * IncrementalIndex. See {@link DimensionIndexer} interface for more information.
   *
   * @return A new DimensionIndexer object.
   */
  public DimensionIndexer makeIndexer();


  /**
   * Creates a new DimensionMergerV9, a per-dimension object responsible for merging indexes/row data across segments
   * and building the on-disk representation of a dimension. For use with IndexMergerV9 only.
   *
   * See {@link DimensionMergerV9} interface for more information.
   *
   * @param indexSpec     Specification object for the index merge
   * @param outDir        Location to store files generated by the merging process
   * @param ioPeon        ioPeon object passed in by IndexMerger, manages files created by the merging process
   * @param capabilities  The ColumnCapabilities of the dimension represented by this DimensionHandler
   * @param progress      ProgressIndicator used by the merging process

   * @return A new DimensionMergerV9 object.
   */
  public DimensionMergerV9 makeMerger(
      IndexSpec indexSpec,
      File outDir,
      IOPeon ioPeon,
      ColumnCapabilities capabilities,
      ProgressIndicator progress
  );


  /**
   * Creates a new DimensionMergerLegacy, a per-dimension object responsible for merging indexes/row data across segments
   * and building the on-disk representation of a dimension. For use with IndexMerger only.
   *
   * See {@link DimensionMergerLegacy} interface for more information.
   *
   * @param indexSpec     Specification object for the index merge
   * @param outDir        Location to store files generated by the merging process
   * @param ioPeon        ioPeon object passed in by IndexMerger, manages files created by the merging process
   * @param capabilities  The ColumnCapabilities of the dimension represented by this DimensionHandler
   * @param progress      ProgressIndicator used by the merging process

   * @return A new DimensionMergerLegacy object.
   */
  public DimensionMergerLegacy makeLegacyMerger(
      IndexSpec indexSpec,
      File outDir,
      IOPeon ioPeon,
      ColumnCapabilities capabilities,
      ProgressIndicator progress
  );


  /**
   * Creates a new DimensionColumnReader, a per-dimension object responsible for reading data from an on-disk column.
   * Used by QueryableIndex and associated wrapper classes.
   *
   * See {@link DimensionColumnReader} interface for more information.
   *
   * @param column The Column object associated with this DimensionHandler's dimension.

   * @return A new DimensionColumnReader object.
   */
  public DimensionColumnReader makeColumnReader(Column column);


  /**
   * Returns a function that attempts to convert Object values to this dimension's type.
   * Needed because the types of arriving row values may not always match this dimension's type during ingestion.
   *
   * If no transformation was performed, the transformation function must return the input object.
   *
   * @return A value transformation function.
   */
  public Function<Object, ActualType> getValueTypeTransformer();


  /**
   * Given an array representing a single set of row value(s) for this dimension as an Object,
   * return the length of the array after appropriate type-casting.
   *
   * For example, a dictionary encoded String dimension would receive an int[] as an Object.
   *
   * @param dimVals Array of row values
   * @return Size of dimVals
   */
  public int getLengthFromArrayObject(Object dimVals);


  /**
   * Given two arrays representing encoded row value(s), return the result of their comparison.
   *
   * If the two arrays have different lengths, the shorter array should be ordered first in the comparison.
   *
   * Otherwise, this function should iterate through the array values and return the comparison of the first difference.
   *
   * @param lhs array of row values
   * @param rhs array of row values
   * @return integer indicating comparison result of arrays
   */
  public int compareRowboatKey(Object lhs, Object rhs);


  /**
   * Helper function for the GroupByQuery.
   *
   * An implementation of this function should:
   * - Read the current encoded row values from selector
   * - For each value in the row value array:
   *   -- duplicate() the oldKey byteBuffer
   *   -- Serialize the value to a byte[] representation and put() the bytes into the key duplicate
   *   -- Call updateFn on the key duplicate.
   *
   * See StringDimensionHandler.groupByUpdater() for a reference implementation.
   *
   * @param selector DimensionSelector object for reading rows
   * @param oldKey   Current GroupBy key
   * @param updateFn Function provided by GroupByQueryEngine, to be called on a duplicated, updated GroupBy key
   * @return
   */
  public List<ByteBuffer> groupByUpdater(DimensionSelector selector, ByteBuffer oldKey, Function<ByteBuffer, List<ByteBuffer>> updateFn);


  /**
   * Get the size of this dimension's EncodedType values
   **
   * @return The size in bytes of a single encoded value, using the same serialization format as the groupByUpdater() implementation.
   */
  public int getEncodedValueSize();


  /**
   * Helper function for the GroupByQuery.
   *
   * Used to compare values for a single dimension within two GroupBy keys.
   *
   * The byte[] arrays will contain a single encoded value, as serialized by the implementation of groupByUpdater().
   *
   * @param lhs array of bytes representing a single encoded value
   * @param rhs array of bytes representing a single encoded value
   * @return comparison of lhs and rhs
   */
  public int compareEncodedValueAsBytes(byte[] lhs, byte[] rhs);


  /**
   * Read a single encoded value, serialized as a byte[] in the format used by groupByUpdater(), and add the
   * de-serialized value to "event", with key "outputName".
   *
   * This function can choose to discard the value instead of adding it to the event Map.
   *
   * @param key        ByteBuffer containing a byte[] representation of a single encoded value, in the format written by groupByUpdater()
   * @param selector   DimensionSelector for this handler's dimension
   * @param event      Map representing a single result event for a GroupBy query.
   * @param outputName The output name for this handler's dimension for the query containing "event"
   */
  public void addValueToEventFromGroupByKey(ByteBuffer key, DimensionSelector selector, Map<String, Object> event, String outputName);
  public void addValueToEventFromGroupByKey(ByteBuffer key, DimensionSelector selector, Map<String, Object> event, String outputName, int position);

  /**
   * Read the current row from a DimensionSelector and return an Iterable containing String representations of each
   * row value.
   *
   * Used by the SearchQueryRunner.
   *
   * @param selector DimensionSelector object for reading rows
   * @return Iterable of String representations of the row values read from the DimensionSelector
   */
  public Iterable<String> getStringIterableFromSelector(DimensionSelector selector);


  /**
   * Read the current row from a DimensionSelector, convert Encoded values to Actual, and return the converted row.
   *
   * For a single valued row, this function should return a single Object.
   *
   * For multi-valued rows, this function should return a list of Objects.
   *
   * Used by the SelectQueryEngine.
   *
   * @return row values read from a DimensionSelector, converted to Actual representation
   */
  public Object getRowValuesForSelect(DimensionSelector selector);
}
