/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.druid.queryng.operators.general;

import org.apache.druid.java.util.metrics.StubServiceEmitter;
import org.apache.druid.query.DefaultQueryMetrics;
import org.apache.druid.query.DruidMetrics;
import org.apache.druid.query.QueryMetrics;
import org.apache.druid.query.scan.ScanQuery;
import org.apache.druid.queryng.Timer;
import org.apache.druid.queryng.fragment.FragmentManager;
import org.apache.druid.queryng.fragment.Fragments;
import org.apache.druid.queryng.operators.MockOperator;
import org.apache.druid.queryng.operators.Operator;
import org.apache.druid.queryng.operators.OperatorTests;
import org.junit.Test;

import java.util.List;
import java.util.Map;
import java.util.function.ObjLongConsumer;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

public class MetricsOperatorTest
{
  /**
   * Mock version of the metric reporter to ensure it is called.
   */
  private static class MockReportMetric implements ObjLongConsumer<QueryMetrics<?>>
  {
    QueryMetrics<?> metrics;
    long value;

    @Override
    public void accept(QueryMetrics<?> t, long value)
    {
      this.metrics = t;
      this.value = value;
    }
  }

  /**
   * Verify the basics. Use a 1 ms wait between each of 5 items so that there
   * is time to report. Verify that the one and only metric is reported: wait
   * time.
   */
  @Test
  public void testTopMetrics()
  {
    QueryMetrics<ScanQuery> metrics = new DefaultQueryMetrics<>();
    StubServiceEmitter emitter = new StubServiceEmitter("service", "host");
    Timer waitTimer = Timer.createStarted();
    try {
      // 2 ms sleep, so wait time is not 0
      Thread.sleep(2);
    }
    catch (InterruptedException e) {
      // Ignore
    }
    MockReportMetric reportMetric = new MockReportMetric();
    FragmentManager fragment = Fragments.defaultFragment();
    Operator<Integer> leaf = MockOperator.ints(fragment, 5);
    Operator<Integer> sleepOp = OperatorTests.sleepOperator(fragment, leaf, 1);
    Operator<Integer> op = new MetricsOperator<Integer>(
        fragment,
        emitter,
        metrics,
        reportMetric,
        waitTimer,
        sleepOp
    );
    fragment.registerRoot(op);
    List<Integer> results = fragment.toList();
    assertEquals(5, results.size());
    assertSame(metrics, reportMetric.metrics);
    assertTrue(reportMetric.value > 0);
    assertEquals(1, emitter.getEvents().size());
    Map<String, Object> recovered = emitter.getEvents().get(0).toMap();
    assertNull(recovered.get(DruidMetrics.STATUS));
    assertEquals("query/wait/time", recovered.get("metric"));
    assertTrue((Long) recovered.get("value") > 0);
  }

  @Test
  public void testInnerMetrics()
  {
    QueryMetrics<ScanQuery> metrics = new DefaultQueryMetrics<>();
    StubServiceEmitter emitter = new StubServiceEmitter("service", "host");
    MockReportMetric reportMetric = new MockReportMetric();
    FragmentManager fragment = Fragments.defaultFragment();
    Operator<Integer> leaf = MockOperator.ints(fragment, 5);
    Operator<Integer> sleepOp = OperatorTests.sleepOperator(fragment, leaf, 1);
    Operator<Integer> op = new MetricsOperator<Integer>(
        fragment,
        emitter,
        metrics,
        reportMetric,
        null,
        sleepOp
    );
    fragment.registerRoot(op);
    List<Integer> results = fragment.toList();
    assertEquals(5, results.size());
    assertSame(metrics, reportMetric.metrics);
    assertTrue(reportMetric.value > 0);
    assertTrue(emitter.getEvents().isEmpty());
  }

  /**
   * Inner metrics: no wait timer so no metrics generated by the metrics
   * operator itself.
   */
  @Test
  public void testFailedMetrics()
  {
    QueryMetrics<ScanQuery> metrics = new DefaultQueryMetrics<>();
    StubServiceEmitter emitter = new StubServiceEmitter("service", "host");
    Timer waitTimer = Timer.createStarted();
    try {
      // 2 ms sleep, so wait time is not 0
      Thread.sleep(2);
    }
    catch (InterruptedException e) {
      // Ignore
    }
    MockReportMetric reportMetric = new MockReportMetric();
    FragmentManager fragment = Fragments.defaultFragment();
    Operator<Integer> leaf = MockOperator.ints(fragment, 5);
    Operator<Integer> sleepOp = OperatorTests.sleepOperator(fragment, leaf, 1);
    Operator<Integer> failOp = OperatorTests.failOperator(fragment, sleepOp, 3);
    Operator<Integer> op = new MetricsOperator<Integer>(
        fragment,
        emitter,
        metrics,
        reportMetric,
        waitTimer,
        failOp
    );
    fragment.registerRoot(op);

    try {
      fragment.toList();
      fail();
    }
    catch (RuntimeException e) {
      // Expected
    }

    assertSame(metrics, reportMetric.metrics);
    assertTrue(reportMetric.value > 0);
    assertEquals(1, emitter.getEvents().size());
    Map<String, Object> recovered = emitter.getEvents().get(0).toMap();
    assertEquals("failed", recovered.get(DruidMetrics.STATUS));
    assertEquals("query/wait/time", recovered.get("metric"));
    assertTrue((Long) recovered.get("value") > 0);
  }
}
