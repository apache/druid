!use druidtest://?numMergeBuffers=3
!set outputformat mysql

SELECT
          cnt,
          SUM(CASE WHEN dim1 <> '1' THEN 1 ELSE 0 END) + SUM(cnt)
        FROM druid.foo
GROUP BY cnt;
+-----+--------+
| cnt | EXPR$1 |
+-----+--------+
|   1 |     11 |
+-----+--------+
(1 row)

!ok
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "cnt",
    "outputName" : "d0",
    "outputType" : "LONG"
  } ],
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "count",
      "name" : "a0"
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "equals",
        "column" : "dim1",
        "matchValueType" : "STRING",
        "matchValue" : "1"
      }
    },
    "name" : "a0"
  }, {
    "type" : "longSum",
    "name" : "a1",
    "fieldName" : "cnt"
  } ],
  "postAggregations" : [ {
    "type" : "expression",
    "name" : "p0",
    "expression" : "(\"a0\" + \"a1\")",
    "outputType" : "LONG"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
!nativePlan
!druidPlan
LogicalProject(cnt=[$0], EXPR$1=[+($1, $2)])
  LogicalAggregate(group=[{0}], agg#0=[SUM($1)], agg#1=[SUM($0)])
    LogicalProject(cnt=[$4], $f1=[CASE(<>($1, '1'), 1, 0)])
      LogicalTableScan(table=[[druid, foo]])

!logicalPlan
LogicalProject(cnt=[$0], EXPR$1=[+($1, $2)])
  LogicalAggregate(group=[{0}], agg#0=[SUM($1)], agg#1=[SUM($0)])
    LogicalProject(cnt=[$4], $f1=[CASE(<>($1, '1'), 1, 0)])
      LogicalTableScan(table=[[druid, foo]])

!convertedPlan
