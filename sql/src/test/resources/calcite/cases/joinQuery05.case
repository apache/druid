Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
==============================================================
Test cases from the CalciteJoinQueryTest file

==============================================================
Converted from testLeftJoinRightTableCanBeEmpty()

HashJoinSegmentStorageAdapter is not vectorizable
=== case
Left join right table can be empty
=== SQL
SELECT v1.dim2, count(1)
FROM (
  SELECT *
  FROM foo
  where m1 > 2
  ) v1
LEFT OUTER JOIN (
  select dim2 from (
    select * from foo where m2 is null)
    ) sm
  ON v1.dim2 = sm.dim2
group by 1
=== options
sqlCompatibleNulls=false
vectorize=false
=== schema
dim2 VARCHAR
EXPR$1 BIGINT
=== plan
LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
  LogicalProject(dim2=[$3], $f1=[1])
    LogicalJoin(condition=[=($3, $8)], joinType=[left])
      LogicalProject(__time=[$0], cnt=[$1], dim1=[$2], dim2=[$3], dim3=[$4], m1=[$5], m2=[$6], unique_dim1=[$7])
        LogicalFilter(condition=[>($5, 2)])
          LogicalTableScan(table=[[druid, foo]])
      LogicalProject(dim2=[$3])
        LogicalFilter(condition=[IS NULL($6)])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "bound",
          "dimension" : "m1",
          "lower" : "2",
          "lowerStrict" : true,
          "ordering" : {
            "type" : "numeric"
          }
        },
        "columns" : [ "dim2" ],
        "legacy" : false,
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "right" : {
      "type" : "inline",
      "columnNames" : [ "dim2", "m2" ],
      "columnTypes" : [ "STRING", "DOUBLE" ],
      "rows" : [ ]
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"dim2\" == \"j0.dim2\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
["",2]
["a",1]
["abc",1]
==============================================================
Converted from testLeftJoinRightTableCanBeEmpty()

HashJoinSegmentStorageAdapter is not vectorizable
=== case
Left join right table can be empty
=== SQL copy
=== options
sqlCompatibleNulls=true
vectorize=false
=== schema copy
=== plan copy
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "bound",
          "dimension" : "m1",
          "lower" : "2",
          "lowerStrict" : true,
          "ordering" : {
            "type" : "numeric"
          }
        },
        "columns" : [ "dim2" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "m2"
        },
        "columns" : [ "dim2" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"dim2\" == \"j0.dim2\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
[null,1]
["",1]
["a",1]
["abc",1]
==============================================================
Converted from testLeftJoinSubqueryWithNullKeyFilter()
=== case
Left join subquery with null key filter
=== SQL
SELECT dim1, l1.k
FROM foo
LEFT JOIN (select k || '' as k from lookup.lookyloo group by 1) l1 ON foo.dim1 = l1.k
WHERE l1.k IS NOT NULL
=== options
provider=QueryContextForJoinProviderNoFilterRewrite
sqlCompatibleNulls=false
vectorize=false
=== schema
dim1 VARCHAR
k VARCHAR
=== plan
LogicalProject(dim1=[$2], k=[$8])
  LogicalFilter(condition=[IS NOT NULL($8)])
    LogicalJoin(condition=[=($2, $8)], joinType=[left])
      LogicalTableScan(table=[[druid, foo]])
      LogicalAggregate(group=[{0}])
        LogicalProject(k=[||($0, '')])
          LogicalTableScan(table=[[lookup, lookyloo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "groupBy",
        "dataSource" : {
          "type" : "lookup",
          "lookup" : "lookyloo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "concat(\"k\",'')",
          "outputType" : "STRING"
        } ],
        "granularity" : {
          "type" : "all"
        },
        "dimensions" : [ {
          "type" : "default",
          "dimension" : "v0",
          "outputName" : "d0",
          "outputType" : "STRING"
        } ],
        "limitSpec" : {
          "type" : "NoopLimitSpec"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"dim1\" == \"j0.d0\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "filter" : {
    "type" : "not",
    "field" : {
      "type" : "selector",
      "dimension" : "j0.d0",
      "value" : null
    }
  },
  "columns" : [ "dim1", "j0.d0" ],
  "legacy" : false,
  "granularity" : {
    "type" : "all"
  }
}
=== run
=== results
["abc","abc"]
==============================================================
Converted from testLeftJoinSubqueryWithNullKeyFilter()

This result is incorrect.
TODO: fix this result when the JoinFilterAnalyzer bug is fixed.
=== case
Left join subquery with null key filter
=== SQL copy
=== options
provider=QueryContextForJoinProviderWithFilterRewrite
sqlCompatibleNulls=false
vectorize=false
=== schema copy
=== plan copy
=== native copy
=== results
["10.1",""]
["2",""]
["1",""]
["def",""]
["abc","abc"]
==============================================================
Converted from testLeftJoinSubqueryWithNullKeyFilter()
=== case
Left join subquery with null key filter
=== SQL copy
=== options
provider=QueryContextForJoinProviderNoFilterRewrite
sqlCompatibleNulls=true
vectorize=false
=== schema copy
=== plan copy
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "groupBy",
        "dataSource" : {
          "type" : "lookup",
          "lookup" : "lookyloo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "concat(\"k\",'')",
          "outputType" : "STRING"
        } ],
        "granularity" : {
          "type" : "all"
        },
        "dimensions" : [ {
          "type" : "default",
          "dimension" : "v0",
          "outputName" : "d0",
          "outputType" : "STRING"
        } ],
        "limitSpec" : {
          "type" : "NoopLimitSpec"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"dim1\" == \"j0.d0\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "columns" : [ "dim1", "j0.d0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
["abc","abc"]
==============================================================
Converted from testLeftJoinSubqueryWithNullKeyFilter()

This result is incorrect.
TODO: fix this result when the JoinFilterAnalyzer bug is fixed.
=== case
Left join subquery with null key filter
=== SQL copy
=== options
provider=QueryContextForJoinProviderWithFilterRewrite
sqlCompatibleNulls=true
vectorize=false
=== schema copy
=== plan copy
=== native copy
=== results
["abc","abc"]
==============================================================
Converted from testLeftJoinSubqueryWithSelectorFilter()
=== case
Left join subquery with selector filter
=== SQL
SELECT dim1, l1.k
FROM foo
LEFT JOIN (select k || '' as k from lookup.lookyloo group by 1) l1 ON foo.dim1 = l1.k
WHERE l1.k = 'abc'
=== context
computeInnerJoinCostAsFilter=false
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=false
=== schema
dim1 VARCHAR
k VARCHAR
=== plan
LogicalProject(dim1=[$2], k=[$8])
  LogicalFilter(condition=[=($8, 'abc')])
    LogicalJoin(condition=[=($2, $8)], joinType=[left])
      LogicalTableScan(table=[[druid, foo]])
      LogicalAggregate(group=[{0}])
        LogicalProject(k=[||($0, '')])
          LogicalTableScan(table=[[lookup, lookyloo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "groupBy",
        "dataSource" : {
          "type" : "lookup",
          "lookup" : "lookyloo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "concat(\"k\",'')",
          "outputType" : "STRING"
        } ],
        "granularity" : {
          "type" : "all"
        },
        "dimensions" : [ {
          "type" : "default",
          "dimension" : "v0",
          "outputName" : "d0",
          "outputType" : "STRING"
        } ],
        "limitSpec" : {
          "type" : "NoopLimitSpec"
        },
        "context" : {
          "computeInnerJoinCostAsFilter" : "false"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"dim1\" == \"j0.d0\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "filter" : {
    "type" : "selector",
    "dimension" : "j0.d0",
    "value" : "abc"
  },
  "columns" : [ "dim1", "j0.d0" ],
  "legacy" : false,
  "context" : {
    "computeInnerJoinCostAsFilter" : "false"
  },
  "granularity" : {
    "type" : "all"
  }
}
=== results
["abc","abc"]
==============================================================
Converted from testLeftJoinWithNotNullFilter()
=== case
Left join with not null filter
=== SQL
SELECT s.dim1, t.dim1
FROM foo as s
LEFT JOIN foo as t ON s.dim1 = t.dim1 and s.dim1 IS NOT NULL
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
dim1 VARCHAR
=== plan
LogicalProject(dim1=[$2], dim10=[$10])
  LogicalJoin(condition=[AND(=($2, $10), IS NOT NULL($2))], joinType=[left])
    LogicalTableScan(table=[[druid, foo]])
    LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "columns" : [ "dim1" ],
        "legacy" : false,
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"dim1\" == \"j0.dim1\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "columns" : [ "dim1", "j0.dim1" ],
  "legacy" : false,
  "granularity" : {
    "type" : "all"
  }
}
=== results
["",""]
["10.1","10.1"]
["2","2"]
["1","1"]
["def","def"]
["abc","abc"]
==============================================================
Converted from testInnerJoinSubqueryWithSelectorFilter()

Cannot vectorize due to 'concat' expression.
=== case
Inner join subquery with selector filter
=== SQL
SELECT dim1, l1.k
FROM foo INNER JOIN (
  select k || '' as k
  from lookup.lookyloo
  group by 1
  ) l1 ON foo.dim1 = l1.k and l1.k = 'abc'
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=false
=== schema
dim1 VARCHAR
k VARCHAR
=== plan
LogicalProject(dim1=[$2], k=[$8])
  LogicalJoin(condition=[AND(=($2, $8), =($8, 'abc'))], joinType=[inner])
    LogicalTableScan(table=[[druid, foo]])
    LogicalAggregate(group=[{0}])
      LogicalProject(k=[||($0, '')])
        LogicalTableScan(table=[[lookup, lookyloo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "groupBy",
        "dataSource" : {
          "type" : "lookup",
          "lookup" : "lookyloo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "concat(\"k\",'')",
          "outputType" : "STRING"
        } ],
        "granularity" : {
          "type" : "all"
        },
        "dimensions" : [ {
          "type" : "default",
          "dimension" : "v0",
          "outputName" : "d0",
          "outputType" : "STRING"
        } ],
        "limitSpec" : {
          "type" : "NoopLimitSpec"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "((\"dim1\" == \"j0.d0\") && ('abc' == \"j0.d0\"))",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "columns" : [ "dim1", "j0.d0" ],
  "legacy" : false,
  "granularity" : {
    "type" : "all"
  }
}
=== results
["abc","abc"]
==============================================================
Converted from testSemiJoinWithOuterTimeExtractScan()
=== case
Semi join with outer time extract scan
=== SQL
SELECT dim1, EXTRACT(MONTH FROM __time) FROM druid.foo
 WHERE dim2 IN (
   SELECT dim2
   FROM druid.foo
   WHERE dim1 = 'def'
 ) AND dim1 <> ''
=== options
sqlCompatibleNulls=false
vectorize=true
=== schema
dim1 VARCHAR
EXPR$1 BIGINT
=== plan
LogicalProject(dim1=[$2], EXPR$1=[EXTRACT(FLAG(MONTH), $0)])
  LogicalFilter(condition=[AND(IN($3, {
LogicalProject(dim2=[$3])
  LogicalFilter(condition=[=($2, 'def')])
    LogicalTableScan(table=[[druid, foo]])
}), <>($2, ''))])
    LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "groupBy",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "def"
        },
        "granularity" : {
          "type" : "all"
        },
        "dimensions" : [ {
          "type" : "default",
          "dimension" : "dim2",
          "outputName" : "d0",
          "outputType" : "STRING"
        } ],
        "limitSpec" : {
          "type" : "NoopLimitSpec"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"dim2\" == \"j0.d0\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "timestamp_extract(\"__time\",'MONTH','UTC')",
    "outputType" : "LONG"
  } ],
  "resultFormat" : "compactedList",
  "filter" : {
    "type" : "not",
    "field" : {
      "type" : "selector",
      "dimension" : "dim1",
      "value" : null
    }
  },
  "columns" : [ "dim1", "v0" ],
  "legacy" : false,
  "granularity" : {
    "type" : "all"
  }
}
=== results
["def",1]
==============================================================
Converted from testSemiJoinWithOuterTimeExtractScan()
=== case
Semi join with outer time extract scan
=== SQL copy
=== options
sqlCompatibleNulls=true
vectorize=true
=== schema copy
=== plan copy
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "groupBy",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "def"
        },
        "granularity" : {
          "type" : "all"
        },
        "dimensions" : [ {
          "type" : "default",
          "dimension" : "dim2",
          "outputName" : "d0",
          "outputType" : "STRING"
        } ],
        "limitSpec" : {
          "type" : "NoopLimitSpec"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"dim2\" == \"j0.d0\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "timestamp_extract(\"__time\",'MONTH','UTC')",
    "outputType" : "LONG"
  } ],
  "resultFormat" : "compactedList",
  "filter" : {
    "type" : "not",
    "field" : {
      "type" : "selector",
      "dimension" : "dim1",
      "value" : ""
    }
  },
  "columns" : [ "dim1", "v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results copy
==============================================================
Converted from testTwoSemiJoinsSimultaneously()

Fully removing the join allows this query to vectorize.
=== case
Two semi joins simultaneously
=== SQL
SELECT dim1, COUNT(*) FROM foo
WHERE dim1 IN ('abc', 'def')AND __time IN (SELECT MAX(__time) FROM foo WHERE cnt = 1)
AND __time IN (SELECT MAX(__time) FROM foo WHERE cnt <> 2)
GROUP BY 1
=== context
enableTimeBoundaryPlanning=true
maxTimeArrayOutputName=a0
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=false
=== schema
dim1 VARCHAR
EXPR$1 BIGINT
=== plan
LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
  LogicalProject(dim1=[$2])
    LogicalFilter(condition=[AND(OR(=($2, 'abc'), =($2, 'def')), IN($0, {
LogicalAggregate(group=[{}], EXPR$0=[MAX($0)])
  LogicalProject(__time=[$0])
    LogicalFilter(condition=[=($1, 1)])
      LogicalTableScan(table=[[druid, foo]])
}), IN($0, {
LogicalAggregate(group=[{}], EXPR$0=[MAX($0)])
  LogicalProject(__time=[$0])
    LogicalFilter(condition=[<>($1, 2)])
      LogicalTableScan(table=[[druid, foo]])
}))])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "join",
      "left" : {
        "type" : "table",
        "name" : "foo"
      },
      "right" : {
        "type" : "query",
        "query" : {
          "queryType" : "timeBoundary",
          "dataSource" : {
            "type" : "table",
            "name" : "foo"
          },
          "intervals" : {
            "type" : "intervals",
            "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
          },
          "bound" : "maxTime",
          "filter" : {
            "type" : "selector",
            "dimension" : "cnt",
            "value" : "1"
          },
          "context" : {
            "enableTimeBoundaryPlanning" : true,
            "maxTimeArrayOutputName" : "a0"
          },
          "granularity" : {
            "type" : "all"
          }
        }
      },
      "rightPrefix" : "j0.",
      "condition" : "(\"__time\" == \"j0.a0\")",
      "joinType" : "INNER"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "timeBoundary",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "bound" : "maxTime",
        "filter" : {
          "type" : "not",
          "field" : {
            "type" : "selector",
            "dimension" : "cnt",
            "value" : "2"
          }
        },
        "context" : {
          "enableTimeBoundaryPlanning" : true,
          "maxTimeArrayOutputName" : "a0"
        },
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "_j0.",
    "condition" : "(\"__time\" == \"_j0.a0\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "in",
    "dimension" : "dim1",
    "values" : [ "abc", "def" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim1",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  },
  "context" : {
    "enableTimeBoundaryPlanning" : true,
    "maxTimeArrayOutputName" : "a0"
  }
}
=== results
["abc",1]
==============================================================
Converted from testSemiAndAntiJoinSimultaneouslyUsingWhereInSubquery()
=== case
Semi and anti join simultaneously using where in subquery
=== SQL
SELECT dim1, COUNT(*) FROM foo
WHERE dim1 IN ('abc', 'def')
AND __time IN (SELECT MAX(__time) FROM foo)
AND __time NOT IN (SELECT MIN(__time) FROM foo)
GROUP BY 1
=== context
enableTimeBoundaryPlanning=true
maxTimeArrayOutputName=a0
minTimeArrayOutputName=a0
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=false
vectorize=false
=== schema
dim1 VARCHAR
EXPR$1 BIGINT
=== plan
LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
  LogicalProject(dim1=[$2])
    LogicalFilter(condition=[AND(OR(=($2, 'abc'), =($2, 'def')), IN($0, {
LogicalAggregate(group=[{}], EXPR$0=[MAX($0)])
  LogicalProject(__time=[$0])
    LogicalTableScan(table=[[druid, foo]])
}), NOT(IN($0, {
LogicalAggregate(group=[{}], EXPR$0=[MIN($0)])
  LogicalProject(__time=[$0])
    LogicalTableScan(table=[[druid, foo]])
})))])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "join",
      "left" : {
        "type" : "join",
        "left" : {
          "type" : "table",
          "name" : "foo"
        },
        "right" : {
          "type" : "query",
          "query" : {
            "queryType" : "timeBoundary",
            "dataSource" : {
              "type" : "table",
              "name" : "foo"
            },
            "intervals" : {
              "type" : "intervals",
              "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
            },
            "bound" : "maxTime",
            "context" : {
              "enableTimeBoundaryPlanning" : true,
              "maxTimeArrayOutputName" : "a0",
              "minTimeArrayOutputName" : "a0"
            },
            "granularity" : {
              "type" : "all"
            }
          }
        },
        "rightPrefix" : "j0.",
        "condition" : "(\"__time\" == \"j0.a0\")",
        "joinType" : "INNER"
      },
      "right" : {
        "type" : "query",
        "query" : {
          "queryType" : "groupBy",
          "dataSource" : {
            "type" : "query",
            "query" : {
              "queryType" : "timeBoundary",
              "dataSource" : {
                "type" : "table",
                "name" : "foo"
              },
              "intervals" : {
                "type" : "intervals",
                "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
              },
              "bound" : "minTime",
              "context" : {
                "enableTimeBoundaryPlanning" : true,
                "maxTimeArrayOutputName" : "a0",
                "minTimeArrayOutputName" : "a0"
              },
              "granularity" : {
                "type" : "all"
              }
            }
          },
          "intervals" : {
            "type" : "intervals",
            "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
          },
          "granularity" : {
            "type" : "all"
          },
          "dimensions" : [ ],
          "aggregations" : [ {
            "type" : "count",
            "name" : "_a0"
          }, {
            "type" : "count",
            "name" : "_a1"
          } ],
          "limitSpec" : {
            "type" : "NoopLimitSpec"
          },
          "context" : {
            "enableTimeBoundaryPlanning" : true,
            "maxTimeArrayOutputName" : "a0",
            "minTimeArrayOutputName" : "a0"
          }
        }
      },
      "rightPrefix" : "_j0.",
      "condition" : "1",
      "joinType" : "INNER"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "timeseries",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "granularity" : {
          "type" : "all"
        },
        "aggregations" : [ {
          "type" : "longMin",
          "name" : "a0",
          "fieldName" : "__time"
        } ],
        "postAggregations" : [ {
          "type" : "expression",
          "name" : "p0",
          "expression" : "1"
        } ],
        "context" : {
          "enableTimeBoundaryPlanning" : true,
          "maxTimeArrayOutputName" : "a0",
          "minTimeArrayOutputName" : "a0"
        }
      }
    },
    "rightPrefix" : "__j0.",
    "condition" : "(\"__time\" == \"__j0.a0\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "and",
    "fields" : [ {
      "type" : "in",
      "dimension" : "dim1",
      "values" : [ "abc", "def" ]
    }, {
      "type" : "or",
      "fields" : [ {
        "type" : "selector",
        "dimension" : "_j0._a0",
        "value" : "0"
      }, {
        "type" : "and",
        "fields" : [ {
          "type" : "selector",
          "dimension" : "__j0.p0",
          "value" : null
        }, {
          "type" : "expression",
          "expression" : "(\"_j0._a1\" >= \"_j0._a0\")"
        } ]
      } ]
    } ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim1",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  },
  "context" : {
    "enableTimeBoundaryPlanning" : true,
    "maxTimeArrayOutputName" : "a0",
    "minTimeArrayOutputName" : "a0"
  }
}
=== results
["abc",1]
==============================================================
Converted from testSemiAndAntiJoinSimultaneouslyUsingWhereInSubquery()
=== case
Semi and anti join simultaneously using where in subquery
=== SQL copy
=== context copy
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=true
vectorize=false
=== schema copy
=== plan copy
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "join",
      "left" : {
        "type" : "join",
        "left" : {
          "type" : "table",
          "name" : "foo"
        },
        "right" : {
          "type" : "query",
          "query" : {
            "queryType" : "timeBoundary",
            "dataSource" : {
              "type" : "table",
              "name" : "foo"
            },
            "intervals" : {
              "type" : "intervals",
              "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
            },
            "bound" : "maxTime",
            "context" : {
              "enableTimeBoundaryPlanning" : true,
              "maxTimeArrayOutputName" : "a0",
              "minTimeArrayOutputName" : "a0"
            },
            "granularity" : {
              "type" : "all"
            }
          }
        },
        "rightPrefix" : "j0.",
        "condition" : "(\"__time\" == \"j0.a0\")",
        "joinType" : "INNER"
      },
      "right" : {
        "type" : "query",
        "query" : {
          "queryType" : "groupBy",
          "dataSource" : {
            "type" : "query",
            "query" : {
              "queryType" : "timeBoundary",
              "dataSource" : {
                "type" : "table",
                "name" : "foo"
              },
              "intervals" : {
                "type" : "intervals",
                "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
              },
              "bound" : "minTime",
              "context" : {
                "enableTimeBoundaryPlanning" : true,
                "maxTimeArrayOutputName" : "a0",
                "minTimeArrayOutputName" : "a0"
              },
              "granularity" : {
                "type" : "all"
              }
            }
          },
          "intervals" : {
            "type" : "intervals",
            "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
          },
          "granularity" : {
            "type" : "all"
          },
          "dimensions" : [ ],
          "aggregations" : [ {
            "type" : "count",
            "name" : "_a0"
          }, {
            "type" : "filtered",
            "aggregator" : {
              "type" : "count",
              "name" : "_a1"
            },
            "filter" : {
              "type" : "not",
              "field" : {
                "type" : "selector",
                "dimension" : "a0"
              }
            },
            "name" : "_a1"
          } ],
          "limitSpec" : {
            "type" : "NoopLimitSpec"
          },
          "context" : {
            "enableTimeBoundaryPlanning" : true,
            "maxTimeArrayOutputName" : "a0",
            "minTimeArrayOutputName" : "a0"
          }
        }
      },
      "rightPrefix" : "_j0.",
      "condition" : "1",
      "joinType" : "INNER"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "timeseries",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "granularity" : {
          "type" : "all"
        },
        "aggregations" : [ {
          "type" : "longMin",
          "name" : "a0",
          "fieldName" : "__time"
        } ],
        "postAggregations" : [ {
          "type" : "expression",
          "name" : "p0",
          "expression" : "1"
        } ],
        "context" : {
          "enableTimeBoundaryPlanning" : true,
          "maxTimeArrayOutputName" : "a0",
          "minTimeArrayOutputName" : "a0"
        }
      }
    },
    "rightPrefix" : "__j0.",
    "condition" : "(\"__time\" == \"__j0.a0\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "and",
    "fields" : [ {
      "type" : "in",
      "dimension" : "dim1",
      "values" : [ "abc", "def" ]
    }, {
      "type" : "or",
      "fields" : [ {
        "type" : "selector",
        "dimension" : "_j0._a0",
        "value" : "0"
      }, {
        "type" : "and",
        "fields" : [ {
          "type" : "selector",
          "dimension" : "__j0.p0"
        }, {
          "type" : "expression",
          "expression" : "(\"_j0._a1\" >= \"_j0._a0\")"
        } ]
      } ]
    } ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim1",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  },
  "context" : {
    "enableTimeBoundaryPlanning" : true,
    "maxTimeArrayOutputName" : "a0",
    "minTimeArrayOutputName" : "a0"
  }
}
=== results copy
==============================================================
Converted from testSemiAndAntiJoinSimultaneouslyUsingExplicitJoins()
=== case
Semi and anti join simultaneously using explicit joins
=== SQL
SELECT dim1, COUNT(*)
FROM
foo INNER JOIN (SELECT MAX(__time) t FROM foo) t0 on t0.t = foo.__time
LEFT JOIN (SELECT MIN(__time) t FROM foo) t1 on t1.t = foo.__time
WHERE dim1 IN ('abc', 'def')
  AND t1.t is null
GROUP BY 1
=== context
enableTimeBoundaryPlanning=true
maxTimeArrayOutputName=a0
minTimeArrayOutputName=a0
=== options
provider=QueryContextForJoinProvider
vectorize=false
=== schema
dim1 VARCHAR
EXPR$1 BIGINT
=== plan
LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
  LogicalProject(dim1=[$2])
    LogicalFilter(condition=[AND(OR(=($2, 'abc'), =($2, 'def')), IS NULL($9))])
      LogicalJoin(condition=[=($9, $0)], joinType=[left])
        LogicalJoin(condition=[=($8, $0)], joinType=[inner])
          LogicalTableScan(table=[[druid, foo]])
          LogicalAggregate(group=[{}], t=[MAX($0)])
            LogicalProject(__time=[$0])
              LogicalTableScan(table=[[druid, foo]])
        LogicalAggregate(group=[{}], t=[MIN($0)])
          LogicalProject(__time=[$0])
            LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "join",
      "left" : {
        "type" : "table",
        "name" : "foo"
      },
      "right" : {
        "type" : "query",
        "query" : {
          "queryType" : "timeBoundary",
          "dataSource" : {
            "type" : "table",
            "name" : "foo"
          },
          "intervals" : {
            "type" : "intervals",
            "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
          },
          "bound" : "maxTime",
          "context" : {
            "enableTimeBoundaryPlanning" : true,
            "maxTimeArrayOutputName" : "a0",
            "minTimeArrayOutputName" : "a0"
          },
          "granularity" : {
            "type" : "all"
          }
        }
      },
      "rightPrefix" : "j0.",
      "condition" : "(\"__time\" == \"j0.a0\")",
      "joinType" : "INNER"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "timeBoundary",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "bound" : "minTime",
        "context" : {
          "enableTimeBoundaryPlanning" : true,
          "maxTimeArrayOutputName" : "a0",
          "minTimeArrayOutputName" : "a0"
        },
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "_j0.",
    "condition" : "(\"__time\" == \"_j0.a0\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "and",
    "fields" : [ {
      "type" : "in",
      "dimension" : "dim1",
      "values" : [ "abc", "def" ]
    }, {
      "type" : "selector",
      "dimension" : "_j0.a0",
      "value" : null
    } ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim1",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  },
  "context" : {
    "enableTimeBoundaryPlanning" : true,
    "maxTimeArrayOutputName" : "a0",
    "minTimeArrayOutputName" : "a0"
  }
}
=== run
=== options
sqlCompatibleNulls=both
=== results
["abc",1]
