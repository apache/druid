Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
==============================================================
Converted from testTimeStampAddZeroDayPeriod()
=== case
Time stamp add zero day period
=== SQL
SELECT TIMESTAMPADD(DAY, 0, "__time") FROM druid.foo
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
EXPR$0 TIMESTAMP(3)
=== plan
LogicalProject(EXPR$0=[+($0, *(86400000:INTERVAL DAY, 0))])
  LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "(\"__time\" + 0)",
    "outputType" : "LONG"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
[946684800000]
[946771200000]
[946857600000]
[978307200000]
[978393600000]
[978480000000]
==============================================================
Converted from testTimeStampAddZeroMonthPeriod()
=== case
Time stamp add zero month period
=== SQL
SELECT TIMESTAMPADD(MONTH, 0, "__time") FROM druid.foo
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
EXPR$0 TIMESTAMP(3)
=== plan
LogicalProject(EXPR$0=[+($0, *(1:INTERVAL MONTH, 0))])
  LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "timestamp_shift(\"__time\",'P0M',1,'UTC')",
    "outputType" : "LONG"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
[946684800000]
[946771200000]
[946857600000]
[978307200000]
[978393600000]
[978480000000]
==============================================================
Converted from testTimeStampAddZeroYearPeriod()
=== case
Time stamp add zero year period
=== SQL
SELECT TIMESTAMPADD(YEAR, 0, "__time") FROM druid.foo
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
EXPR$0 TIMESTAMP(3)
=== plan
LogicalProject(EXPR$0=[+($0, *(12:INTERVAL YEAR, 0))])
  LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "timestamp_shift(\"__time\",'P0M',1,'UTC')",
    "outputType" : "LONG"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
[946684800000]
[946771200000]
[946857600000]
[978307200000]
[978393600000]
[978480000000]
==============================================================
Converted from testTimeStampAddConversion()
TIMESTAMPADD is converted to timestamp_shift function call and
its parameters will be converted to a Period string or an expression
see https://github.com/apache/druid/issues/10530 for more information

2nd parameter for TIMESTAMPADD is literal, it will be translated to 'P1M' string
=== case
Time stamp add conversion (1)
=== SQL
SELECT TIMESTAMPADD(MONTH, 1, "__time") FROM druid.foo
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
EXPR$0 TIMESTAMP(3)
=== plan
LogicalProject(EXPR$0=[+($0, *(1:INTERVAL MONTH, 1))])
  LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "timestamp_shift(\"__time\",'P1M',1,'UTC')",
    "outputType" : "LONG"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
[949363200000]
[949449600000]
[949536000000]
[980985600000]
[981072000000]
[981158400000]
==============================================================
Converted from testTimeStampAddConversion()
=== case
Time stamp add conversion (2)
=== SQL
SELECT TIMESTAMPADD(MONTH, "cnt", "__time") FROM druid.foo
=== schema
EXPR$0 TIMESTAMP(3)
=== plan
LogicalProject(EXPR$0=[+($0, *(1:INTERVAL MONTH, $1))])
  LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "timestamp_shift(\"__time\",concat('P', (1 * \"cnt\"), 'M'),1,'UTC')",
    "outputType" : "LONG"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "v0" ],
  "granularity" : {
    "type" : "all"
  }
}
==============================================================
Converted from testGroupingSetsWithLimit()
Cannot vectorize due to virtual columns.
=== case
Grouping sets with limit
=== SQL
SELECT dim2, gran, SUM(cnt)
FROM (
  SELECT
    FLOOR(__time TO MONTH) AS gran,
    COALESCE(dim2, '') dim2, cnt
    FROM druid.foo
    ) AS x
GROUP BY GROUPING SETS ( (dim2, gran), (dim2), (gran), () )
LIMIT 100
=== options
vectorize=false
=== schema
dim2 VARCHAR
gran TIMESTAMP(3)
EXPR$2 BIGINT
=== plan
LogicalSort(fetch=[100])
  LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], EXPR$2=[SUM($2)])
    LogicalProject(dim2=[CASE(IS NOT NULL($3), $3, '':VARCHAR)], gran=[FLOOR($0, FLAG(MONTH))], cnt=[$1])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "case_searched(notnull(\"dim2\"),\"dim2\",'')",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v1",
    "expression" : "timestamp_floor(\"__time\",'P1M',null,'UTC')",
    "outputType" : "LONG"
  } ],
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "v0",
    "outputName" : "d0",
    "outputType" : "STRING"
  }, {
    "type" : "default",
    "dimension" : "v1",
    "outputName" : "d1",
    "outputType" : "LONG"
  } ],
  "aggregations" : [ {
    "type" : "longSum",
    "name" : "a0",
    "fieldName" : "cnt"
  } ],
  "limitSpec" : {
    "type" : "default",
    "columns" : [ ],
    "limit" : 100
  },
  "subtotalsSpec" : [ [ "d0", "d1" ], [ "d0" ], [ "d1" ], [ ] ],
  "context" : {
    "timestampResultField" : "d1",
    "timestampResultFieldGranularity" : "MONTH",
    "timestampResultFieldInOriginalDimensions" : 1
  }
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["",946684800000,2]
["",978307200000,1]
["a",946684800000,1]
["a",978307200000,1]
["abc",978307200000,1]
["",null,3]
["a",null,2]
["abc",null,1]
["",946684800000,3]
["",978307200000,3]
["",null,6]
=== run
=== options
sqlCompatibleNulls=true
=== results
["",946684800000,2]
["",978307200000,1]
["a",946684800000,1]
["a",978307200000,1]
["abc",978307200000,1]
["",null,3]
["a",null,2]
["abc",null,1]
[null,946684800000,3]
[null,978307200000,3]
[null,null,6]
==============================================================
Converted from testGroupingSetsWithLimitOrderByGran()
Cannot vectorize due to virtual columns.
=== case
Grouping sets with limit order by gran
=== SQL
SELECT dim2, gran, SUM(cnt)
FROM (
  SELECT
    FLOOR(__time TO MONTH) AS gran,
    COALESCE(dim2, '') dim2, cnt
    FROM druid.foo
    ) AS x
GROUP BY GROUPING SETS ( (dim2, gran), (dim2), (gran), () )
ORDER BY x.gran
LIMIT 100
=== options
vectorize=false
=== schema
dim2 VARCHAR
gran TIMESTAMP(3)
EXPR$2 BIGINT
=== plan
LogicalSort(sort0=[$1], dir0=[ASC], fetch=[100])
  LogicalAggregate(group=[{0, 1}], groups=[[{0, 1}, {0}, {1}, {}]], EXPR$2=[SUM($2)])
    LogicalProject(dim2=[CASE(IS NOT NULL($3), $3, '':VARCHAR)], gran=[FLOOR($0, FLAG(MONTH))], cnt=[$1])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "case_searched(notnull(\"dim2\"),\"dim2\",'')",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v1",
    "expression" : "timestamp_floor(\"__time\",'P1M',null,'UTC')",
    "outputType" : "LONG"
  } ],
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "v0",
    "outputName" : "d0",
    "outputType" : "STRING"
  }, {
    "type" : "default",
    "dimension" : "v1",
    "outputName" : "d1",
    "outputType" : "LONG"
  } ],
  "aggregations" : [ {
    "type" : "longSum",
    "name" : "a0",
    "fieldName" : "cnt"
  } ],
  "limitSpec" : {
    "type" : "default",
    "columns" : [ {
      "dimension" : "d1",
      "direction" : "ascending",
      "dimensionOrder" : {
        "type" : "numeric"
      }
    } ],
    "limit" : 100
  },
  "subtotalsSpec" : [ [ "d0", "d1" ], [ "d0" ], [ "d1" ], [ ] ],
  "context" : {
    "timestampResultField" : "d1",
    "timestampResultFieldGranularity" : "MONTH",
    "timestampResultFieldInOriginalDimensions" : 1
  }
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["",null,2]
["a",null,1]
["",null,1]
["a",null,1]
["abc",null,1]
["",null,6]
["",946684800000,2]
["a",946684800000,1]
["",946684800000,3]
["",978307200000,1]
["a",978307200000,1]
["abc",978307200000,1]
["",978307200000,3]
=== run
=== options
sqlCompatibleNulls=true
=== results
["",null,2]
["a",null,1]
["",null,1]
["a",null,1]
["abc",null,1]
[null,null,6]
["",946684800000,2]
["a",946684800000,1]
[null,946684800000,3]
["",978307200000,1]
["a",978307200000,1]
["abc",978307200000,1]
[null,978307200000,3]
==============================================================
Converted from testLookupWithNull()
=== case
Lookup with null
=== SQL
SELECT dim2 ,lookup(dim2,'lookyloo') from foo where dim2 is null
=== options
vectorize=true
=== schema
dim2 VARCHAR
EXPR$1 VARCHAR
=== plan
LogicalProject(dim2=[$3], EXPR$1=[LOOKUP($3, 'lookyloo')])
  LogicalFilter(condition=[IS NULL($3)])
    LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "null",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "filter" : {
    "type" : "selector",
    "dimension" : "dim2"
  },
  "columns" : [ "v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["",""]
["",""]
["",""]
=== run
=== options
sqlCompatibleNulls=true
=== results
[null,null]
[null,null]
==============================================================
Converted from testRoundFunc()
=== case
Round func
=== SQL
SELECT f1, round(f1) FROM druid.numfoo
=== options
vectorize=true
=== schema
f1 FLOAT
EXPR$1 FLOAT
=== plan
LogicalProject(f1=[$10], EXPR$1=[ROUND($10)])
  LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "round(\"f1\")",
    "outputType" : "FLOAT"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "f1", "v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== run
=== options
sqlCompatibleNulls=false
=== results
[1.0,1.0]
[0.1,0.0]
[0.0,0.0]
[0.0,0.0]
[0.0,0.0]
[0.0,0.0]
=== run
=== options
sqlCompatibleNulls=true
=== results
[1.0,1.0]
[0.1,0.0]
[0.0,0.0]
[null,null]
[null,null]
[null,null]
==============================================================
Converted from testCountAndAverageByConstantVirtualColumn()
=== case
Count and average by constant virtual column
=== SQL
SELECT
  dim5,
  COUNT(dim1),
  AVG(l1)
FROM druid.numfoo
WHERE dim1 = '10.1'
  AND l1 = 325323
GROUP BY dim5
=== options
sqlCompatibleNulls=false
vectorize=true
=== schema
dim5 VARCHAR
EXPR$1 BIGINT
EXPR$2 BIGINT
=== plan
LogicalAggregate(group=[{0}], EXPR$1=[COUNT($1)], EXPR$2=[AVG($2)])
  LogicalProject(dim5=[$8], dim1=[$4], l1=[$12])
    LogicalFilter(condition=[AND(=($4, '10.1'), =($12, 325323))])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v1",
    "expression" : "325323",
    "outputType" : "LONG"
  } ],
  "filter" : {
    "type" : "and",
    "fields" : [ {
      "type" : "selector",
      "dimension" : "dim1",
      "value" : "10.1"
    }, {
      "type" : "selector",
      "dimension" : "l1",
      "value" : "325323"
    } ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim5",
    "outputName" : "_d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "count",
      "name" : "a0"
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "v0"
      }
    },
    "name" : "a0"
  }, {
    "type" : "longSum",
    "name" : "a1:sum",
    "fieldName" : "v1"
  }, {
    "type" : "count",
    "name" : "a1:count"
  } ],
  "postAggregations" : [ {
    "type" : "arithmetic",
    "name" : "a1",
    "fn" : "quotient",
    "fields" : [ {
      "type" : "fieldAccess",
      "fieldName" : "a1:sum"
    }, {
      "type" : "fieldAccess",
      "fieldName" : "a1:count"
    } ]
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
["ab",1,325323]
==============================================================
Converted from testCountAndAverageByConstantVirtualColumn()
=== case
Count and average by constant virtual column
=== SQL copy
=== options
sqlCompatibleNulls=true
vectorize=true
=== schema copy
=== plan copy
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v1",
    "expression" : "325323",
    "outputType" : "LONG"
  } ],
  "filter" : {
    "type" : "and",
    "fields" : [ {
      "type" : "selector",
      "dimension" : "dim1",
      "value" : "10.1"
    }, {
      "type" : "selector",
      "dimension" : "l1",
      "value" : "325323"
    } ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim5",
    "outputName" : "_d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "count",
      "name" : "a0"
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "v0"
      }
    },
    "name" : "a0"
  }, {
    "type" : "longSum",
    "name" : "a1:sum",
    "fieldName" : "v1"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "count",
      "name" : "a1:count"
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "v1"
      }
    },
    "name" : "a1:count"
  } ],
  "postAggregations" : [ {
    "type" : "arithmetic",
    "name" : "a1",
    "fn" : "quotient",
    "fields" : [ {
      "type" : "fieldAccess",
      "fieldName" : "a1:sum"
    }, {
      "type" : "fieldAccess",
      "fieldName" : "a1:count"
    } ]
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  },
  "context" : {
    "defaultTimeout" : 300000,
    "maxScatterGatherBytes" : 9223372036854775807,
    "sqlCurrentTimestamp" : "2000-01-01T00:00:00Z",
    "sqlQueryId" : "dummy"
  }
}
=== results copy
==============================================================
Converted from testEmptyGroupWithOffsetDoesntInfiniteLoop()
=== case
Empty group with offset doesnt infinite loop
=== SQL
SELECT r0.c, r1.c
FROM (
  SELECT COUNT(*) AS c
  FROM "foo"
  GROUP BY ()
  OFFSET 1
) AS r0
LEFT JOIN (
  SELECT COUNT(*) AS c
  FROM "foo"
  GROUP BY ()
) AS r1 ON TRUE LIMIT 10
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
c BIGINT
c BIGINT
=== plan
LogicalSort(fetch=[10])
  LogicalProject(c=[$0], c0=[$1])
    LogicalJoin(condition=[true], joinType=[left])
      LogicalSort(offset=[1])
        LogicalAggregate(group=[{}], c=[COUNT()])
          LogicalProject($f0=[0])
            LogicalTableScan(table=[[druid, foo]])
      LogicalAggregate(group=[{}], c=[COUNT()])
        LogicalProject($f0=[0])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "query",
      "query" : {
        "queryType" : "groupBy",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "granularity" : {
          "type" : "all"
        },
        "dimensions" : [ ],
        "aggregations" : [ {
          "type" : "count",
          "name" : "a0"
        } ],
        "limitSpec" : {
          "type" : "default",
          "columns" : [ ],
          "offset" : 1,
          "limit" : 10
        }
      }
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "timeseries",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "granularity" : {
          "type" : "all"
        },
        "aggregations" : [ {
          "type" : "count",
          "name" : "a0"
        } ]
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "1",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "limit" : 10,
  "columns" : [ "a0", "j0.a0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
==============================================================
Converted from testJoinWithTimeDimension()
=== case
Join with time dimension
=== SQL
SELECT count(*) FROM druid.foo t1 inner join druid.foo t2 on t1.__time = t2.__time
=== options
sqlCompatibleNulls=both
vectorize=true
=== plan
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[0])
    LogicalJoin(condition=[=($0, $8)], joinType=[inner])
      LogicalTableScan(table=[[druid, foo]])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "columns" : [ "__time" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"__time\" == \"j0.__time\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ]
}
=== results
[6]
==============================================================
Converted from testExpressionCounts()
=== case
Expression counts
=== SQL
SELECT
 COUNT(reverse(dim2)),
 COUNT(left(dim2, 5)),
 COUNT(strpos(dim2, 'a'))
FROM druid.numfoo
=== options
vectorize=false
=== schema
EXPR$0 BIGINT
EXPR$1 BIGINT
EXPR$2 BIGINT
=== plan
LogicalAggregate(group=[{}], EXPR$0=[COUNT($0)], EXPR$1=[COUNT($1)], EXPR$2=[COUNT($2)])
  LogicalProject($f0=[REVERSE($5)], $f1=[LEFT($5, 5)], $f2=[STRPOS($5, 'a')])
    LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "reverse(\"dim2\")",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v1",
    "expression" : "left(\"dim2\",5)",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v2",
    "expression" : "(strpos(\"dim2\",'a') + 1)",
    "outputType" : "LONG"
  } ],
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "count",
      "name" : "a0"
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "v0"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "count",
      "name" : "a1"
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "v1"
      }
    },
    "name" : "a1"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "count",
      "name" : "a2"
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "v2"
      }
    },
    "name" : "a2"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
[3,3,6]
=== run
=== options
sqlCompatibleNulls=true
=== results
[4,4,4]
==============================================================
Converted from testBitwiseAggregatorsTimeseries()
=== case
Bitwise aggregators timeseries
=== SQL
SELECT
  BIT_AND(l1),
  BIT_OR(l1),
  BIT_XOR(l1)
FROM druid.numfoo
=== options
sqlCompatibleNulls=false
vectorize=false
=== schema
EXPR$0 BIGINT
EXPR$1 BIGINT
EXPR$2 BIGINT
=== plan
LogicalAggregate(group=[{}], EXPR$0=[BIT_AND($0)], EXPR$1=[BIT_OR($0)], EXPR$2=[BIT_XOR($0)])
  LogicalProject(l1=[$12])
    LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a0",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : false,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseAnd(\"__acc\", \"l1\")",
      "combine" : "bitwiseAnd(\"__acc\", \"a0\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a1",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : false,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseOr(\"__acc\", \"l1\")",
      "combine" : "bitwiseOr(\"__acc\", \"a1\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a1"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a2",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : false,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseXor(\"__acc\", \"l1\")",
      "combine" : "bitwiseXor(\"__acc\", \"a2\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a2"
  } ]
}
=== results
[0,325327,325324]
==============================================================
Converted from testBitwiseAggregatorsTimeseries()
=== case
Bitwise aggregators timeseries
=== SQL copy
=== options
sqlCompatibleNulls=true
vectorize=false
=== schema copy
=== plan copy
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a0",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseAnd(\"__acc\", \"l1\")",
      "combine" : "bitwiseAnd(\"__acc\", \"a0\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a1",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseOr(\"__acc\", \"l1\")",
      "combine" : "bitwiseOr(\"__acc\", \"a1\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a1"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a2",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseXor(\"__acc\", \"l1\")",
      "combine" : "bitwiseXor(\"__acc\", \"a2\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a2"
  } ],
  "context" : {
    "defaultTimeout" : 300000,
    "maxScatterGatherBytes" : 9223372036854775807,
    "sqlCurrentTimestamp" : "2000-01-01T00:00:00Z",
    "sqlQueryId" : "dummy"
  }
}
=== results copy
==============================================================
Converted from testBitwiseAggregatorsGroupBy()
=== case
Bitwise aggregators group by
=== SQL
SELECT
  dim2,
  BIT_AND(l1),
  BIT_OR(l1),
  BIT_XOR(l1)
FROM druid.numfoo
GROUP BY 1
ORDER BY 4
=== options
sqlCompatibleNulls=false
vectorize=false
=== schema
dim2 VARCHAR
EXPR$1 BIGINT
EXPR$2 BIGINT
EXPR$3 BIGINT
=== plan
LogicalSort(sort0=[$3], dir0=[ASC])
  LogicalAggregate(group=[{0}], EXPR$1=[BIT_AND($1)], EXPR$2=[BIT_OR($1)], EXPR$3=[BIT_XOR($1)])
    LogicalProject(dim2=[$5], l1=[$12])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "_d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a0",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : false,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseAnd(\"__acc\", \"l1\")",
      "combine" : "bitwiseAnd(\"__acc\", \"a0\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a1",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : false,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseOr(\"__acc\", \"l1\")",
      "combine" : "bitwiseOr(\"__acc\", \"a1\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a1"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a2",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : false,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseXor(\"__acc\", \"l1\")",
      "combine" : "bitwiseXor(\"__acc\", \"a2\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a2"
  } ],
  "limitSpec" : {
    "type" : "default",
    "columns" : [ {
      "dimension" : "a2",
      "direction" : "ascending",
      "dimensionOrder" : {
        "type" : "numeric"
      }
    } ]
  }
}
=== results
["abc",0,0,0]
["a",0,7,7]
["",0,325323,325323]
==============================================================
Converted from testBitwiseAggregatorsGroupBy()
=== case
Bitwise aggregators group by
=== SQL copy
=== options
sqlCompatibleNulls=true
vectorize=false
=== schema copy
=== plan copy
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "_d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a0",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseAnd(\"__acc\", \"l1\")",
      "combine" : "bitwiseAnd(\"__acc\", \"a0\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a1",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseOr(\"__acc\", \"l1\")",
      "combine" : "bitwiseOr(\"__acc\", \"a1\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a1"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a2",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "0",
      "initialCombineValue" : "0",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "bitwiseXor(\"__acc\", \"l1\")",
      "combine" : "bitwiseXor(\"__acc\", \"a2\")",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a2"
  } ],
  "limitSpec" : {
    "type" : "default",
    "columns" : [ {
      "dimension" : "a2",
      "direction" : "ascending",
      "dimensionOrder" : {
        "type" : "numeric"
      }
    } ]
  },
  "context" : {
    "defaultTimeout" : 300000,
    "maxScatterGatherBytes" : 9223372036854775807,
    "sqlCurrentTimestamp" : "2000-01-01T00:00:00Z",
    "sqlQueryId" : "dummy"
  }
}
=== results
["abc",null,null,null]
["",0,0,0]
["a",0,7,7]
[null,0,325323,325323]
==============================================================
Converted from testStringAgg()
=== case
String agg
=== SQL
SELECT
  STRING_AGG(dim1,','),
  STRING_AGG(DISTINCT dim1, ','),
  STRING_AGG(DISTINCT dim1,',') FILTER(WHERE dim1 = 'shazbot')
FROM foo
WHERE dim1 is not null
=== options
vectorize=false
=== schema
EXPR$0 VARCHAR
EXPR$1 VARCHAR
EXPR$2 VARCHAR
=== plan
LogicalAggregate(group=[{}], EXPR$0=[STRING_AGG($0, $1)], EXPR$1=[STRING_AGG(DISTINCT $0, $1)], EXPR$2=[STRING_AGG(DISTINCT $0, $1) FILTER $2])
  LogicalProject(dim1=[$2], $f1=[','], $f2=[IS TRUE(=($2, 'shazbot'))])
    LogicalFilter(condition=[IS NOT NULL($2)])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "not",
    "field" : {
      "type" : "selector",
      "dimension" : "dim1"
    }
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a0",
      "fields" : [ "dim1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_append(\"__acc\", \"dim1\")",
      "combine" : "array_concat(\"__acc\", \"a0\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "dim1"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a1",
      "fields" : [ "dim1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_set_add(\"__acc\", \"dim1\")",
      "combine" : "array_set_add_all(\"__acc\", \"a1\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "dim1"
      }
    },
    "name" : "a1"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a2",
      "fields" : [ "dim1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_set_add(\"__acc\", \"dim1\")",
      "combine" : "array_set_add_all(\"__acc\", \"a2\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "and",
      "fields" : [ {
        "type" : "not",
        "field" : {
          "type" : "selector",
          "dimension" : "dim1"
        }
      }, {
        "type" : "selector",
        "dimension" : "dim1",
        "value" : "shazbot"
      } ]
    },
    "name" : "a2"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["10.1,2,1,def,abc","1,10.1,2,abc,def",""]
=== run
=== options
sqlCompatibleNulls=true
=== results
[",10.1,2,1,def,abc",",1,10.1,2,abc,def",null]
==============================================================
Converted from testStringAggMultiValue()
=== case
String agg multi value
=== SQL
SELECT STRING_AGG(dim3, ','), STRING_AGG(DISTINCT dim3, ',')
FROM foo
=== options
vectorize=false
=== schema
EXPR$0 VARCHAR
EXPR$1 VARCHAR
=== plan
LogicalAggregate(group=[{}], EXPR$0=[STRING_AGG($0, $1)], EXPR$1=[STRING_AGG(DISTINCT $0, $1)])
  LogicalProject(dim3=[$4], $f1=[','])
    LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a0",
      "fields" : [ "dim3" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_append(\"__acc\", \"dim3\")",
      "combine" : "array_concat(\"__acc\", \"a0\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "dim3"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a1",
      "fields" : [ "dim3" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_set_add(\"__acc\", \"dim3\")",
      "combine" : "array_set_add_all(\"__acc\", \"a1\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "dim3"
      }
    },
    "name" : "a1"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["a,b,b,c,d","a,b,c,d"]
=== run
=== options
sqlCompatibleNulls=true
=== results
["a,b,b,c,d,",",a,b,c,d"]
==============================================================
Converted from testStringAggNumeric()
=== case
String agg numeric
=== SQL
SELECT STRING_AGG(l1, ','), STRING_AGG(DISTINCT l1, ','), STRING_AGG(d1, ','), STRING_AGG(DISTINCT d1, ','), STRING_AGG(f1, ','), STRING_AGG(DISTINCT f1, ',') FROM numfoo
=== options
vectorize=false
=== schema
EXPR$0 VARCHAR
EXPR$1 VARCHAR
EXPR$2 VARCHAR
EXPR$3 VARCHAR
EXPR$4 VARCHAR
EXPR$5 VARCHAR
=== plan
LogicalAggregate(group=[{}], EXPR$0=[STRING_AGG($0, $1)], EXPR$1=[STRING_AGG(DISTINCT $0, $1)], EXPR$2=[STRING_AGG($2, $1)], EXPR$3=[STRING_AGG(DISTINCT $2, $1)], EXPR$4=[STRING_AGG($3, $1)], EXPR$5=[STRING_AGG(DISTINCT $3, $1)])
  LogicalProject(l1=[$12], $f1=[','], d1=[$2], f1=[$10])
    LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a0",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_append(\"__acc\", \"l1\")",
      "combine" : "array_concat(\"__acc\", \"a0\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a1",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_set_add(\"__acc\", \"l1\")",
      "combine" : "array_set_add_all(\"__acc\", \"a1\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a1"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a2",
      "fields" : [ "d1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_append(\"__acc\", \"d1\")",
      "combine" : "array_concat(\"__acc\", \"a2\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "d1"
      }
    },
    "name" : "a2"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a3",
      "fields" : [ "d1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_set_add(\"__acc\", \"d1\")",
      "combine" : "array_set_add_all(\"__acc\", \"a3\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "d1"
      }
    },
    "name" : "a3"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a4",
      "fields" : [ "f1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_append(\"__acc\", \"f1\")",
      "combine" : "array_concat(\"__acc\", \"a4\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "f1"
      }
    },
    "name" : "a4"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a5",
      "fields" : [ "f1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_set_add(\"__acc\", \"f1\")",
      "combine" : "array_set_add_all(\"__acc\", \"a5\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "f1"
      }
    },
    "name" : "a5"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["7,325323,0,0,0,0","0,325323,7","1.0,1.7,0.0,0.0,0.0,0.0","0.0,1.0,1.7","1.0,0.10000000149011612,0.0,0.0,0.0,0.0","0.0,0.10000000149011612,1.0"]
=== run
=== options
sqlCompatibleNulls=true
=== results
["7,325323,0","0,325323,7","1.0,1.7,0.0","0.0,1.0,1.7","1.0,0.10000000149011612,0.0","0.0,0.10000000149011612,1.0"]
==============================================================
Converted from testStringAggExpression()
=== case
String agg expression
=== SQL
SELECT STRING_AGG(DISTINCT CONCAT(dim1, dim2), ','), STRING_AGG(DISTINCT CONCAT(dim1, dim2), CONCAT('|', '|')) FROM foo
=== options
vectorize=false
=== schema
EXPR$0 VARCHAR
EXPR$1 VARCHAR
=== plan
LogicalAggregate(group=[{}], EXPR$0=[STRING_AGG(DISTINCT $0, $1)], EXPR$1=[STRING_AGG(DISTINCT $0, $2)])
  LogicalProject($f0=[CONCAT($2, $3)], $f1=[','], $f2=[CONCAT('|', '|')])
    LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "concat(\"dim1\",\"dim2\")",
    "outputType" : "STRING"
  } ],
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a0",
      "fields" : [ "v0" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_set_add(\"__acc\", \"v0\")",
      "combine" : "array_set_add_all(\"__acc\", \"a0\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "v0"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a1",
      "fields" : [ "v0" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_set_add(\"__acc\", \"v0\")",
      "combine" : "array_set_add_all(\"__acc\", \"a1\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, '||'))",
      "maxSizeBytes" : 1024
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "v0"
      }
    },
    "name" : "a1"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["10.1,1a,2,a,abc,defabc","10.1||1a||2||a||abc||defabc"]
=== run
=== options
sqlCompatibleNulls=true
=== results
["1a,2,a,defabc","1a||2||a||defabc"]
==============================================================
Converted from testStringAggExpressionNonConstantSeparator()
=== case
String agg expression non constant separator
=== SQL
SELECT STRING_AGG(DISTINCT CONCAT(dim1, dim2), CONCAT('|', dim1)) FROM foo
=== exception
UnsupportedSQLQueryException
=== error
!.* \QPossible error: Aggregation [STRING_AGG(DISTINCT $0, $1)] is not supported\E
==============================================================
Converted from testStringAggMaxBytes()
=== case
String agg max bytes
=== SQL
SELECT STRING_AGG(l1, ',', 128), STRING_AGG(DISTINCT l1, ',', 128) FROM numfoo
=== options
vectorize=false
=== schema
EXPR$0 VARCHAR
EXPR$1 VARCHAR
=== plan
LogicalAggregate(group=[{}], EXPR$0=[STRING_AGG($0, $1, $2)], EXPR$1=[STRING_AGG(DISTINCT $0, $1, $2)])
  LogicalProject(l1=[$12], $f1=[','], $f2=[128])
    LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a0",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_append(\"__acc\", \"l1\")",
      "combine" : "array_concat(\"__acc\", \"a0\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 128
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a0"
  }, {
    "type" : "filtered",
    "aggregator" : {
      "type" : "expression",
      "name" : "a1",
      "fields" : [ "l1" ],
      "accumulatorIdentifier" : "__acc",
      "initialValue" : "[]",
      "initialCombineValue" : "[]",
      "isNullUnlessAggregated" : true,
      "shouldAggregateNullInputs" : false,
      "shouldCombineAggregateNullInputs" : false,
      "fold" : "array_set_add(\"__acc\", \"l1\")",
      "combine" : "array_set_add_all(\"__acc\", \"a1\")",
      "finalize" : "if(array_length(o) == 0, null, array_to_string(o, ','))",
      "maxSizeBytes" : 128
    },
    "filter" : {
      "type" : "not",
      "field" : {
        "type" : "selector",
        "dimension" : "l1"
      }
    },
    "name" : "a1"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["7,325323,0,0,0,0","0,325323,7"]
=== run
=== options
sqlCompatibleNulls=true
=== results
["7,325323,0","0,325323,7"]
==============================================================
Converted from testHumanReadableFormatFunction()
NOTE: the first expression HUMAN_READABLE_BINARY_BYTE_FORMAT(45678)
in SQL is calculated during SQL parse phase,
so the converted Druid native query is its result intead of the
raw function call

Output values:
"44.61 KiB", // 45678 / 1024
"48.22 KiB", // = m1(4.0) * 12345 / 1024
"48 KiB", // = m1(4.0) * 12345 / 1024, precision = 0
"49.38 KB", // decimal byte format, m1(4.0) * 12345 / 1000
"49.38 K", // decimal format, m1(4.0) * 12345 / 1000
=== case
Human readable format function
=== SQL
SELECT
  m1,
  HUMAN_READABLE_BINARY_BYTE_FORMAT(45678),
  HUMAN_READABLE_BINARY_BYTE_FORMAT(m1*12345),
  HUMAN_READABLE_BINARY_BYTE_FORMAT(m1*12345, 0),
  HUMAN_READABLE_DECIMAL_BYTE_FORMAT(m1*12345),
  HUMAN_READABLE_DECIMAL_FORMAT(m1*12345),
  HUMAN_READABLE_BINARY_BYTE_FORMAT(l1),
  HUMAN_READABLE_DECIMAL_BYTE_FORMAT(l1),
  HUMAN_READABLE_DECIMAL_FORMAT(l1)
FROM numfoo
WHERE dim1 = '1'
LIMIT 1
=== options
vectorize=true
=== schema
m1 FLOAT
EXPR$1 VARCHAR
EXPR$2 VARCHAR
EXPR$3 VARCHAR
EXPR$4 VARCHAR
EXPR$5 VARCHAR
EXPR$6 VARCHAR
EXPR$7 VARCHAR
EXPR$8 VARCHAR
=== plan
LogicalSort(fetch=[1])
  LogicalProject(m1=[$14], EXPR$1=[HUMAN_READABLE_BINARY_BYTE_FORMAT(45678)], EXPR$2=[HUMAN_READABLE_BINARY_BYTE_FORMAT(*($14, 12345))], EXPR$3=[HUMAN_READABLE_BINARY_BYTE_FORMAT(*($14, 12345), 0)], EXPR$4=[HUMAN_READABLE_DECIMAL_BYTE_FORMAT(*($14, 12345))], EXPR$5=[HUMAN_READABLE_DECIMAL_FORMAT(*($14, 12345))], EXPR$6=[HUMAN_READABLE_BINARY_BYTE_FORMAT($12)], EXPR$7=[HUMAN_READABLE_DECIMAL_BYTE_FORMAT($12)], EXPR$8=[HUMAN_READABLE_DECIMAL_FORMAT($12)])
    LogicalFilter(condition=[=($4, '1')])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "'44.61 KiB'",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v1",
    "expression" : "human_readable_binary_byte_format((\"m1\" * 12345))",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v2",
    "expression" : "human_readable_binary_byte_format((\"m1\" * 12345),0)",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v3",
    "expression" : "human_readable_decimal_byte_format((\"m1\" * 12345))",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v4",
    "expression" : "human_readable_decimal_format((\"m1\" * 12345))",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v5",
    "expression" : "human_readable_binary_byte_format(\"l1\")",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v6",
    "expression" : "human_readable_decimal_byte_format(\"l1\")",
    "outputType" : "STRING"
  }, {
    "type" : "expression",
    "name" : "v7",
    "expression" : "human_readable_decimal_format(\"l1\")",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "limit" : 1,
  "filter" : {
    "type" : "selector",
    "dimension" : "dim1",
    "value" : "1"
  },
  "columns" : [ "m1", "v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7" ],
  "granularity" : {
    "type" : "all"
  }
}
=== run
=== options
sqlCompatibleNulls=false
=== results
[4.0,"44.61 KiB","48.22 KiB","48 KiB","49.38 KB","49.38 K","0 B","0 B","0"]
=== run
=== options
sqlCompatibleNulls=true
=== results
[4.0,"44.61 KiB","48.22 KiB","48 KiB","49.38 KB","49.38 K",null,null,null]
