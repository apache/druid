Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
==============================================================
Test cases from the CalciteJoinQueryTest file

==============================================================
Converted from testUsingSubqueryWithExtractionFns()
=== case
USING subquery with extraction fns
=== SQL
SELECT dim2, COUNT(*)
FROM druid.foo
WHERE substring(dim2, 1, 1) IN (SELECT substring(dim1, 1, 1)
FROM druid.foo WHERE dim1 <> '')
group by dim2
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=false
vectorize=false
=== schema
dim2 VARCHAR
EXPR$1 BIGINT
=== plan
LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
  LogicalProject(dim2=[$3])
    LogicalFilter(condition=[IN(SUBSTRING($3, 1, 1), {
LogicalProject(EXPR$0=[SUBSTRING($2, 1, 1)])
  LogicalFilter(condition=[<>($2, '')])
    LogicalTableScan(table=[[druid, foo]])
})])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "groupBy",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "filter" : {
          "type" : "not",
          "field" : {
            "type" : "selector",
            "dimension" : "dim1"
          }
        },
        "granularity" : {
          "type" : "all"
        },
        "dimensions" : [ {
          "type" : "extraction",
          "dimension" : "dim1",
          "outputName" : "d0",
          "outputType" : "STRING",
          "extractionFn" : {
            "type" : "substring",
            "index" : 0,
            "length" : 1
          }
        } ],
        "limitSpec" : {
          "type" : "NoopLimitSpec"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(substring(\"dim2\", 0, 1) == \"j0.d0\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
["a",2]
["abc",1]
==============================================================
Converted from testUsingSubqueryWithExtractionFns()
=== case
USING subquery with extraction fns
=== SQL copy
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=true
vectorize=false
=== schema copy
=== plan copy
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "groupBy",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "filter" : {
          "type" : "not",
          "field" : {
            "type" : "selector",
            "dimension" : "dim1",
            "value" : ""
          }
        },
        "granularity" : {
          "type" : "all"
        },
        "dimensions" : [ {
          "type" : "extraction",
          "dimension" : "dim1",
          "outputName" : "d0",
          "outputType" : "STRING",
          "extractionFn" : {
            "type" : "substring",
            "index" : 0,
            "length" : 1
          }
        } ],
        "limitSpec" : {
          "type" : "NoopLimitSpec"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(substring(\"dim2\", 0, 1) == \"j0.d0\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
["a",2]
["abc",1]
==============================================================
Converted from testInnerJoinWithIsNullFilter()
=== case
INNER JOIN with IS NULL filter
=== SQL
SELECT dim1, l.v
from druid.foo f inner join lookup.lookyloo l on f.dim1 = l.k
where f.dim2 is null
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
v VARCHAR
=== plan
LogicalProject(dim1=[$2], v=[$9])
  LogicalFilter(condition=[IS NULL($3)])
    LogicalJoin(condition=[=($2, $8)], joinType=[inner])
      LogicalTableScan(table=[[druid, foo]])
      LogicalTableScan(table=[[lookup, lookyloo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "lookup",
      "lookup" : "lookyloo"
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"dim1\" == \"j0.k\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "filter" : {
    "type" : "selector",
    "dimension" : "dim2"
  },
  "columns" : [ "dim1", "j0.v" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
["abc","xabc"]
==============================================================
Converted from testInnerJoinOnMultiValueColumn()
regression test for https://github.com/apache/druid/issues/9924
Disabled in the Java file
==============================================================
Converted from testLeftJoinOnTwoInlineDataSourcesWithTimeFilter()
=== case
LEFT JOIN on two inline datasources with time filter
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
    AND "__time" >= '1999'
)
SELECT t1.dim1, t1."__time"
from abc as t1
LEFT JOIN abc as t2
on t1.dim1 = t2.dim1
WHERE t1.dim1 = '10.1'
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalFilter(condition=[=($0, '10.1')])
    LogicalJoin(condition=[=($0, $3)], joinType=[left])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[AND(=($2, '10.1'), >=($0, CAST('1999'):TIMESTAMP(3) NOT NULL))])
          LogicalTableScan(table=[[druid, foo]])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[AND(=($2, '10.1'), >=($0, CAST('1999'):TIMESTAMP(3) NOT NULL))])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "1999-01-01T00:00:00.000Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "'10.1'",
          "outputType" : "STRING"
        } ],
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "__time", "v0" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "1999-01-01T00:00:00.000Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "'10.1'",
          "outputType" : "STRING"
        } ],
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "v0" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"v0\" == \"j0.v0\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "_v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "filter" : {
    "type" : "selector",
    "dimension" : "v0",
    "value" : "10.1"
  },
  "columns" : [ "__time", "_v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testLeftJoinOnTwoInlineDataSourcesWithTimeFilter_withLeftDirectAccess()
=== case
LEFT JOIN on two inline datasources with time filter - with left direct access
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
    AND "__time" >= '1999'
)
SELECT t1.dim1, t1."__time"
from abc as t1
LEFT JOIN abc as t2
on t1.dim1 = t2.dim1
WHERE t1.dim1 = '10.1'
=== context
enableJoinLeftTableScanDirect=true
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalFilter(condition=[=($0, '10.1')])
    LogicalJoin(condition=[=($0, $3)], joinType=[left])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[AND(=($2, '10.1'), >=($0, CAST('1999'):TIMESTAMP(3) NOT NULL))])
          LogicalTableScan(table=[[druid, foo]])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[AND(=($2, '10.1'), >=($0, CAST('1999'):TIMESTAMP(3) NOT NULL))])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "1999-01-01T00:00:00.000Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "'10.1'",
          "outputType" : "STRING"
        } ],
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "v0" ],
        "context" : {
          "enableJoinLeftTableScanDirect" : true
        },
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "('10.1' == \"j0.v0\")",
    "joinType" : "LEFT",
    "leftFilter" : {
      "type" : "selector",
      "dimension" : "dim1",
      "value" : "10.1"
    }
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "1999-01-01T00:00:00.000Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "__time", "v0" ],
  "context" : {
    "enableJoinLeftTableScanDirect" : true
  },
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testLeftJoinOnTwoInlineDataSourcesWithOuterWhere()
=== case
LEFT JOIN on two inline datasources with outer WHERE
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
)
SELECT t1.dim1, t1."__time"
from abc as t1 LEFT JOIN abc as t2 on t1.dim1 = t2.dim1
WHERE t1.dim1 = '10.1'
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalFilter(condition=[=($0, '10.1')])
    LogicalJoin(condition=[=($0, $3)], joinType=[left])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[=($2, '10.1')])
          LogicalTableScan(table=[[druid, foo]])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[=($2, '10.1')])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "'10.1'",
          "outputType" : "STRING"
        } ],
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "__time", "v0" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "dim1" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"v0\" == \"j0.dim1\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "_v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "filter" : {
    "type" : "selector",
    "dimension" : "v0",
    "value" : "10.1"
  },
  "columns" : [ "__time", "_v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testLeftJoinOnTwoInlineDataSourcesWithOuterWhere_withLeftDirectAccess()
=== case
LEFT JOIN on two inline datasources with outer WHERE - with left direct access
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
)
SELECT t1.dim1, t1."__time"
from abc as t1 LEFT JOIN abc as t2 on t1.dim1 = t2.dim1
WHERE t1.dim1 = '10.1'
=== context
enableJoinLeftTableScanDirect=true
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalFilter(condition=[=($0, '10.1')])
    LogicalJoin(condition=[=($0, $3)], joinType=[left])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[=($2, '10.1')])
          LogicalTableScan(table=[[druid, foo]])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[=($2, '10.1')])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "dim1" ],
        "context" : {
          "enableJoinLeftTableScanDirect" : true
        },
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "('10.1' == \"j0.dim1\")",
    "joinType" : "LEFT",
    "leftFilter" : {
      "type" : "selector",
      "dimension" : "dim1",
      "value" : "10.1"
    }
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "__time", "v0" ],
  "context" : {
    "enableJoinLeftTableScanDirect" : true
  },
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testLeftJoinOnTwoInlineDataSources()
=== case
LEFT JOIN on two inline datasources
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
)
SELECT t1.dim1, t1."__time"
from abc as t1 LEFT JOIN abc as t2 on t1.dim1 = t2.dim1
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalJoin(condition=[=($0, $3)], joinType=[left])
    LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
      LogicalFilter(condition=[=($2, '10.1')])
        LogicalTableScan(table=[[druid, foo]])
    LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
      LogicalFilter(condition=[=($2, '10.1')])
        LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "'10.1'",
          "outputType" : "STRING"
        } ],
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "__time", "v0" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "dim1" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"v0\" == \"j0.dim1\")",
    "joinType" : "LEFT"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "_v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "__time", "_v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testLeftJoinOnTwoInlineDataSources_withLeftDirectAccess()
=== case
LEFT JOIN on two inline datasources - with left direct access
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
)
SELECT t1.dim1, t1."__time" from abc as t1 LEFT JOIN abc as t2 on t1.dim1 = t2.dim1
=== context
enableJoinLeftTableScanDirect=true
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalJoin(condition=[=($0, $3)], joinType=[left])
    LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
      LogicalFilter(condition=[=($2, '10.1')])
        LogicalTableScan(table=[[druid, foo]])
    LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
      LogicalFilter(condition=[=($2, '10.1')])
        LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "dim1" ],
        "context" : {
          "enableJoinLeftTableScanDirect" : true
        },
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "('10.1' == \"j0.dim1\")",
    "joinType" : "LEFT",
    "leftFilter" : {
      "type" : "selector",
      "dimension" : "dim1",
      "value" : "10.1"
    }
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "__time", "v0" ],
  "context" : {
    "enableJoinLeftTableScanDirect" : true
  },
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testInnerJoinOnTwoInlineDataSourcesWithOuterWhere()
=== case
INNER JOIN on two inline datasources with outer WHERE
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
)
SELECT t1.dim1, t1."__time"
from abc as t1 INNER JOIN abc as t2 on t1.dim1 = t2.dim1
WHERE t1.dim1 = '10.1'
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=false
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalFilter(condition=[=($0, '10.1')])
    LogicalJoin(condition=[=($0, $3)], joinType=[inner])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[=($2, '10.1')])
          LogicalTableScan(table=[[druid, foo]])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[=($2, '10.1')])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "'10.1'",
          "outputType" : "STRING"
        } ],
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "__time", "v0" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "dim1" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"v0\" == \"j0.dim1\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "_v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "filter" : {
    "type" : "not",
    "field" : {
      "type" : "selector",
      "dimension" : "v0"
    }
  },
  "columns" : [ "__time", "_v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testInnerJoinOnTwoInlineDataSourcesWithOuterWhere()
=== case
INNER JOIN on two inline datasources with outer WHERE
=== SQL copy
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=true
vectorize=true
=== schema copy
=== plan copy
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "'10.1'",
          "outputType" : "STRING"
        } ],
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "__time", "v0" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "dim1" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"v0\" == \"j0.dim1\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "_v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "__time", "_v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testInnerJoinOnTwoInlineDataSourcesWithOuterWhere_withLeftDirectAccess()
=== case
INNER JOIN on two inline datasources with outer WHERE - with left direct access
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
)
SELECT t1.dim1, t1."__time" from abc as t1
INNER JOIN abc as t2 on t1.dim1 = t2.dim1
WHERE t1.dim1 = '10.1'
=== context
enableJoinLeftTableScanDirect=true
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalFilter(condition=[=($0, '10.1')])
    LogicalJoin(condition=[=($0, $3)], joinType=[inner])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[=($2, '10.1')])
          LogicalTableScan(table=[[druid, foo]])
      LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
        LogicalFilter(condition=[=($2, '10.1')])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "dim1" ],
        "context" : {
          "enableJoinLeftTableScanDirect" : true
        },
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "('10.1' == \"j0.dim1\")",
    "joinType" : "INNER",
    "leftFilter" : {
      "type" : "selector",
      "dimension" : "dim1",
      "value" : "10.1"
    }
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "__time", "v0" ],
  "context" : {
    "enableJoinLeftTableScanDirect" : true
  },
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testInnerJoinOnTwoInlineDataSources()
=== case
INNER JOIN on two inline datasources
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
)
SELECT t1.dim1, t1."__time" from abc as t1
INNER JOIN abc as t2 on t1.dim1 = t2.dim1
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalJoin(condition=[=($0, $3)], joinType=[inner])
    LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
      LogicalFilter(condition=[=($2, '10.1')])
        LogicalTableScan(table=[[druid, foo]])
    LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
      LogicalFilter(condition=[=($2, '10.1')])
        LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "virtualColumns" : [ {
          "type" : "expression",
          "name" : "v0",
          "expression" : "'10.1'",
          "outputType" : "STRING"
        } ],
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "__time", "v0" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "dim1" ],
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "(\"v0\" == \"j0.dim1\")",
    "joinType" : "INNER"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "_v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "__time", "_v0" ],
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testInnerJoinOnTwoInlineDataSources_withLeftDirectAccess()
=== case
INNER JOIN on two inline datasources - with left direct access
=== SQL
with abc as
(
  SELECT dim1, "__time", m1
  from foo
  WHERE "dim1" = '10.1'
)
SELECT t1.dim1, t1."__time" from abc as t1
INNER JOIN abc as t2 on t1.dim1 = t2.dim1
=== context
enableJoinLeftTableScanDirect=true
=== options
provider=QueryContextForJoinProvider
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
__time TIMESTAMP(3)
=== plan
LogicalProject(dim1=[$0], __time=[$1])
  LogicalJoin(condition=[=($0, $3)], joinType=[inner])
    LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
      LogicalFilter(condition=[=($2, '10.1')])
        LogicalTableScan(table=[[druid, foo]])
    LogicalProject(dim1=[$2], __time=[$0], m1=[$5])
      LogicalFilter(condition=[=($2, '10.1')])
        LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "join",
    "left" : {
      "type" : "table",
      "name" : "foo"
    },
    "right" : {
      "type" : "query",
      "query" : {
        "queryType" : "scan",
        "dataSource" : {
          "type" : "table",
          "name" : "foo"
        },
        "intervals" : {
          "type" : "intervals",
          "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
        },
        "resultFormat" : "compactedList",
        "filter" : {
          "type" : "selector",
          "dimension" : "dim1",
          "value" : "10.1"
        },
        "columns" : [ "dim1" ],
        "context" : {
          "enableJoinLeftTableScanDirect" : true
        },
        "granularity" : {
          "type" : "all"
        }
      }
    },
    "rightPrefix" : "j0.",
    "condition" : "('10.1' == \"j0.dim1\")",
    "joinType" : "INNER",
    "leftFilter" : {
      "type" : "selector",
      "dimension" : "dim1",
      "value" : "10.1"
    }
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "'10.1'",
    "outputType" : "STRING"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "__time", "v0" ],
  "context" : {
    "enableJoinLeftTableScanDirect" : true
  },
  "granularity" : {
    "type" : "all"
  }
}
=== results
["10.1",946771200000]
==============================================================
Converted from testJoinOnConstantShouldFail()

This query is expected to fail as we do not support join with
a constant in the on condition (see issue
https://github.com/apache/druid/issues/9942 for more information)
TODO: Remove expected Exception when
https://github.com/apache/druid/issues/9942 is fixed
=== case
Join on constant should fail
=== SQL
SELECT t1.dim1 from foo as t1 LEFT JOIN foo as t2 on t1.dim1 = '10.1'
=== options
provider=QueryContextForJoinProvider
vectorize=true
=== exception
UnsupportedSQLQueryException
=== error
Cannot build plan for query: SELECT t1.dim1 from foo as t1 LEFT JOIN foo as t2 on t1.dim1 = '10.1'. Possible error: SQL is resulting in a join that has unsupported operand types.
