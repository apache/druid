Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
==============================================================
Converted from testUnionAllTablesWhenCastAndMappingIsRequired()
Cannot plan this UNION ALL operation, because the column swap
would require generating a subquery.
=== case
Union all tables when cast and mapping is required
=== SQL
SELECT c, COUNT(*)
FROM (
  SELECT dim1 AS c, m1
  FROM foo
  UNION ALL
  SELECT cnt AS c, m1
  FROM numfoo
  )
WHERE c = 'a'
   OR c = 'def'
GROUP BY 1
=== exception
UnsupportedSQLQueryException
=== error
!Cannot build plan for query: SELECT.*
**
!.*Possible error: SQL requires union between inputs that are not simple table scans and involve a filter or aliasing. Or column types of tables being unioned are not of same type.
==============================================================
Converted from testUnionAllSameTableTwice()
=== case
Union all same table twice
=== SQL
SELECT
dim1, dim2, SUM(m1), COUNT(*)
FROM (SELECT * FROM foo UNION ALL SELECT * FROM foo)
WHERE dim2 = 'a' OR dim2 = 'def'
GROUP BY 1, 2
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
dim2 VARCHAR
EXPR$2 DOUBLE
EXPR$3 BIGINT
=== plan
LogicalAggregate(group=[{0, 1}], EXPR$2=[SUM($2)], EXPR$3=[COUNT()])
  LogicalProject(dim1=[$2], dim2=[$3], m1=[$5])
    LogicalFilter(condition=[OR(=($3, 'a'), =($3, 'def'))])
      LogicalUnion(all=[true])
        LogicalProject(__time=[$0], cnt=[$1], dim1=[$2], dim2=[$3], dim3=[$4], m1=[$5], m2=[$6], unique_dim1=[$7])
          LogicalTableScan(table=[[druid, foo]])
        LogicalProject(__time=[$0], cnt=[$1], dim1=[$2], dim2=[$3], dim3=[$4], m1=[$5], m2=[$6], unique_dim1=[$7])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "union",
    "dataSources" : [ {
      "type" : "table",
      "name" : "foo"
    }, {
      "type" : "table",
      "name" : "foo"
    } ]
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "in",
    "dimension" : "dim2",
    "values" : [ "a", "def" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim1",
    "outputName" : "d0",
    "outputType" : "STRING"
  }, {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "d1",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "doubleSum",
    "name" : "a0",
    "fieldName" : "m1"
  }, {
    "type" : "count",
    "name" : "a1"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
["","a",2.0,2]
["1","a",8.0,2]
==============================================================
Converted from testUnionAllSameTableTwiceWithSameMapping()
=== case
Union all same table twice with same mapping
=== SQL
SELECT dim1, dim2, SUM(m1), COUNT(*)
FROM (
  SELECT dim1, dim2, m1
  FROM foo
  UNION ALL
  SELECT dim1, dim2, m1
  FROM foo
  )
WHERE dim2 = 'a'
   OR dim2 = 'def'
GROUP BY 1, 2
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
dim2 VARCHAR
EXPR$2 DOUBLE
EXPR$3 BIGINT
=== plan
LogicalAggregate(group=[{0, 1}], EXPR$2=[SUM($2)], EXPR$3=[COUNT()])
  LogicalFilter(condition=[OR(=($1, 'a'), =($1, 'def'))])
    LogicalUnion(all=[true])
      LogicalProject(dim1=[$2], dim2=[$3], m1=[$5])
        LogicalTableScan(table=[[druid, foo]])
      LogicalProject(dim1=[$2], dim2=[$3], m1=[$5])
        LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "union",
    "dataSources" : [ {
      "type" : "table",
      "name" : "foo"
    }, {
      "type" : "table",
      "name" : "foo"
    } ]
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "in",
    "dimension" : "dim2",
    "values" : [ "a", "def" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim1",
    "outputName" : "d0",
    "outputType" : "STRING"
  }, {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "d1",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "doubleSum",
    "name" : "a0",
    "fieldName" : "m1"
  }, {
    "type" : "count",
    "name" : "a1"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
["","a",2.0,2]
["1","a",8.0,2]
==============================================================
Converted from testUnionAllSameTableTwiceWithDifferentMapping()
Cannot plan this UNION ALL operation, because the column swap
would require generating a subquery.
=== case
Union all same table twice with different mapping
=== SQL
SELECT dim1, dim2, SUM(m1), COUNT(*)
FROM (
  SELECT dim1, dim2, m1
  FROM foo
  UNION ALL
  SELECT dim2, dim1, m1
  FROM foo
  )
WHERE dim2 = 'a'
   OR dim2 = 'def'
GROUP BY 1, 2
=== exception
UnsupportedSQLQueryException
=== error
!Cannot build plan for query: SELECT.*
**
!.*Possible error: SQL requires union between two tables and column names queried for each table are different .*
==============================================================
Converted from testUnionAllSameTableThreeTimes()
=== case
Union all same table three times
=== SQL
SELECT
dim1, dim2, SUM(m1), COUNT(*)
FROM (
  SELECT * FROM foo
  UNION ALL
  SELECT * FROM foo
  UNION ALL
  SELECT * FROM foo
  )
WHERE dim2 = 'a'
   OR dim2 = 'def'
GROUP BY 1, 2
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
dim2 VARCHAR
EXPR$2 DOUBLE
EXPR$3 BIGINT
=== plan
LogicalAggregate(group=[{0, 1}], EXPR$2=[SUM($2)], EXPR$3=[COUNT()])
  LogicalProject(dim1=[$2], dim2=[$3], m1=[$5])
    LogicalFilter(condition=[OR(=($3, 'a'), =($3, 'def'))])
      LogicalUnion(all=[true])
        LogicalUnion(all=[true])
          LogicalProject(__time=[$0], cnt=[$1], dim1=[$2], dim2=[$3], dim3=[$4], m1=[$5], m2=[$6], unique_dim1=[$7])
            LogicalTableScan(table=[[druid, foo]])
          LogicalProject(__time=[$0], cnt=[$1], dim1=[$2], dim2=[$3], dim3=[$4], m1=[$5], m2=[$6], unique_dim1=[$7])
            LogicalTableScan(table=[[druid, foo]])
        LogicalProject(__time=[$0], cnt=[$1], dim1=[$2], dim2=[$3], dim3=[$4], m1=[$5], m2=[$6], unique_dim1=[$7])
          LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "union",
    "dataSources" : [ {
      "type" : "table",
      "name" : "foo"
    }, {
      "type" : "table",
      "name" : "foo"
    }, {
      "type" : "table",
      "name" : "foo"
    } ]
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "in",
    "dimension" : "dim2",
    "values" : [ "a", "def" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim1",
    "outputName" : "d0",
    "outputType" : "STRING"
  }, {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "d1",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "doubleSum",
    "name" : "a0",
    "fieldName" : "m1"
  }, {
    "type" : "count",
    "name" : "a1"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
["","a",3.0,3]
["1","a",12.0,3]
==============================================================
Converted from testUnionAllThreeTablesColumnCountMismatch1()
=== case
Union all three tables column count mismatch1
=== SQL
SELECT dim1, dim2, SUM(m1), COUNT(*)
FROM (
  SELECT *
  FROM numfoo
  UNION ALL
  SELECT *
  FROM foo
  UNION ALL
  SELECT *
  from foo
  )
WHERE dim2 = 'a'
   OR dim2 = 'def'
GROUP BY 1, 2
=== error
!.*Column count mismatch in UNION ALL
==============================================================
Converted from testUnionAllThreeTablesColumnCountMismatch2()
=== case
Union all three tables column count mismatch2
=== SQL
SELECT dim1, dim2, SUM(m1), COUNT(*)
FROM (
  SELECT *
  FROM numfoo
  UNION ALL
  SELECT *
  FROM foo
  UNION ALL
  SELECT *
  from foo
  )
WHERE dim2 = 'a'
   OR dim2 = 'def'
GROUP BY 1, 2
=== error
!.*Column count mismatch in UNION ALL
==============================================================
Converted from testUnionAllThreeTablesColumnCountMismatch3()
=== case
Union all three tables column count mismatch3
=== SQL
SELECT dim1, dim2, SUM(m1), COUNT(*)
FROM (
  SELECT * FROM foo
  UNION ALL
  SELECT * FROM foo
  UNION ALL
  SELECT * from numfoo
  )
WHERE dim2 = 'a'
   OR dim2 = 'def'
GROUP BY 1, 2
=== error
!.*Column count mismatch in UNION ALL
==============================================================
Converted from testUnionAllSameTableThreeTimesWithSameMapping()
=== case
Union all same table three times with same mapping
=== SQL
SELECT dim1, dim2, SUM(m1), COUNT(*)
FROM (
  SELECT dim1, dim2, m1 FROM foo
  UNION ALL
  SELECT dim1, dim2, m1 FROM foo
  UNION ALL
  SELECT dim1, dim2, m1 FROM foo
  )
WHERE dim2 = 'a' OR dim2 = 'def'
GROUP BY 1, 2
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
dim1 VARCHAR
dim2 VARCHAR
EXPR$2 DOUBLE
EXPR$3 BIGINT
=== plan
LogicalAggregate(group=[{0, 1}], EXPR$2=[SUM($2)], EXPR$3=[COUNT()])
  LogicalFilter(condition=[OR(=($1, 'a'), =($1, 'def'))])
    LogicalUnion(all=[true])
      LogicalUnion(all=[true])
        LogicalProject(dim1=[$2], dim2=[$3], m1=[$5])
          LogicalTableScan(table=[[druid, foo]])
        LogicalProject(dim1=[$2], dim2=[$3], m1=[$5])
          LogicalTableScan(table=[[druid, foo]])
      LogicalProject(dim1=[$2], dim2=[$3], m1=[$5])
        LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "union",
    "dataSources" : [ {
      "type" : "table",
      "name" : "foo"
    }, {
      "type" : "table",
      "name" : "foo"
    }, {
      "type" : "table",
      "name" : "foo"
    } ]
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "in",
    "dimension" : "dim2",
    "values" : [ "a", "def" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "dim1",
    "outputName" : "d0",
    "outputType" : "STRING"
  }, {
    "type" : "default",
    "dimension" : "dim2",
    "outputName" : "d1",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "doubleSum",
    "name" : "a0",
    "fieldName" : "m1"
  }, {
    "type" : "count",
    "name" : "a1"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
["","a",3.0,3]
["1","a",12.0,3]
==============================================================
Converted from testPruneDeadAggregators()
Test for ProjectAggregatePruneUnusedCallRule.
=== case
Prune dead aggregators
=== SQL
SELECT
  CASE 'foo'
  WHEN 'bar' THEN SUM(cnt)
  WHEN 'foo' THEN SUM(m1)
  WHEN 'baz' THEN SUM(m2)
  END
FROM foo
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
EXPR$0 DOUBLE
=== plan
LogicalProject(EXPR$0=[$1])
  LogicalAggregate(group=[{}], agg#0=[SUM($0)], agg#1=[SUM($1)], agg#2=[SUM($2)])
    LogicalProject(cnt=[$1], m1=[$5], m2=[$6])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "doubleSum",
    "name" : "a0",
    "fieldName" : "m1"
  } ]
}
=== results
[21.0]
==============================================================
Converted from testPruneDeadAggregatorsThroughPostProjection()
Test for ProjectAggregatePruneUnusedCallRule.
=== case
Prune dead aggregators through post projection
=== SQL
SELECT
  CASE 'foo'
  WHEN 'bar' THEN SUM(cnt) / 10
  WHEN 'foo' THEN SUM(m1) / 10
  WHEN 'baz' THEN SUM(m2) / 10
  END
FROM foo
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
EXPR$0 DOUBLE
=== plan
LogicalProject(EXPR$0=[/($1, 10)])
  LogicalAggregate(group=[{}], agg#0=[SUM($0)], agg#1=[SUM($1)], agg#2=[SUM($2)])
    LogicalProject(cnt=[$1], m1=[$5], m2=[$6])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "doubleSum",
    "name" : "a0",
    "fieldName" : "m1"
  } ],
  "postAggregations" : [ {
    "type" : "expression",
    "name" : "p0",
    "expression" : "(\"a0\" / 10)"
  } ]
}
=== results
[2.1]
==============================================================
Converted from testPruneDeadAggregatorsThroughHaving()
Test for ProjectAggregatePruneUnusedCallRule.
=== case
Prune dead aggregators through having
=== SQL
SELECT
  CASE 'foo'
  WHEN 'bar' THEN SUM(cnt)
  WHEN 'foo' THEN SUM(m1)
  WHEN 'baz' THEN SUM(m2)
  END AS theCase
FROM foo
HAVING theCase = 21
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
theCase DOUBLE
=== plan
LogicalProject(theCase=[$1])
  LogicalFilter(condition=[=($1, 21)])
    LogicalAggregate(group=[{}], agg#0=[SUM($0)], agg#1=[SUM($1)], agg#2=[SUM($2)])
      LogicalProject(cnt=[$1], m1=[$5], m2=[$6])
        LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ ],
  "aggregations" : [ {
    "type" : "doubleSum",
    "name" : "a0",
    "fieldName" : "m1"
  } ],
  "having" : {
    "type" : "filter",
    "filter" : {
      "type" : "selector",
      "dimension" : "a0",
      "value" : "21"
    },
    "finalize" : true
  },
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== results
[21.0]
==============================================================
Converted from testGroupByCaseWhen()
Cannot vectorize due to virtual columns.
=== case
Group by case when
=== SQL
SELECT
  CASE EXTRACT(DAY FROM __time)
    WHEN m1 THEN 'match-m1'
    WHEN cnt THEN 'match-cnt'
    WHEN 0 THEN 'zero'
    END,
    COUNT(*)
FROM druid.foo
GROUP BY  CASE EXTRACT(DAY FROM __time)
    WHEN m1 THEN 'match-m1'
    WHEN cnt THEN 'match-cnt'
    WHEN 0 THEN 'zero'
    END
=== options
vectorize=false
=== schema
EXPR$0 VARCHAR(9)
EXPR$1 BIGINT
=== plan
LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
  LogicalProject(EXPR$0=[CASE(=(CAST(EXTRACT(FLAG(DAY), $0)):FLOAT NOT NULL, $5), 'match-m1':VARCHAR(9), =(EXTRACT(FLAG(DAY), $0), $1), 'match-cnt':VARCHAR(9), =(EXTRACT(FLAG(DAY), $0), 0), 'zero':VARCHAR(9), null:VARCHAR(9))])
    LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "case_searched((CAST(timestamp_extract(\"__time\",'DAY','UTC'), 'DOUBLE') == \"m1\"),'match-m1',(timestamp_extract(\"__time\",'DAY','UTC') == \"cnt\"),'match-cnt',(timestamp_extract(\"__time\",'DAY','UTC') == 0),'zero',null)",
    "outputType" : "STRING"
  } ],
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "v0",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["",2]
["match-cnt",1]
["match-m1",3]
=== run
=== options
sqlCompatibleNulls=true
=== results
[null,2]
["match-cnt",1]
["match-m1",3]
==============================================================
Converted from testGroupByCaseWhenOfTripleAnd()
Cannot vectorize due to virtual columns.
=== case
Group by case when of triple and
=== SQL
SELECT
  CASE WHEN m1 > 1 AND m1 < 5 AND cnt = 1 THEN 'x' ELSE NULL END,
  COUNT(*)
FROM druid.foo
GROUP BY 1
=== options
vectorize=false
=== schema
EXPR$0 CHAR(1)
EXPR$1 BIGINT
=== plan
LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
  LogicalProject(EXPR$0=[CASE(AND(>($5, 1), <($5, 5), =($1, 1)), 'x', null:CHAR(1))])
    LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "groupBy",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "case_searched(((\"m1\" > 1) && (\"m1\" < 5) && (\"cnt\" == 1)),'x',null)",
    "outputType" : "STRING"
  } ],
  "granularity" : {
    "type" : "all"
  },
  "dimensions" : [ {
    "type" : "default",
    "dimension" : "v0",
    "outputName" : "d0",
    "outputType" : "STRING"
  } ],
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "limitSpec" : {
    "type" : "NoopLimitSpec"
  }
}
=== run
=== options
sqlCompatibleNulls=false
=== results
["",3]
["x",3]
=== run
=== options
sqlCompatibleNulls=true
=== results
[null,3]
["x",3]
==============================================================
Converted from testNullEmptyStringEquality()
Ideally the NATIVE filter should be simplified to
(dim2 == 'a' || dim2 IS NULL),
the (dim2 != 'a') component is unnecessary.
=== case
Null empty string equality
=== SQL
SELECT COUNT(*)
FROM druid.foo
WHERE NULLIF(dim2, 'a') IS NULL
=== options
vectorize=true
=== schema
EXPR$0 BIGINT
=== plan
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[0])
    LogicalFilter(condition=[IS NULL(CASE(=($3, 'a'), null:VARCHAR, $3))])
      LogicalTableScan(table=[[druid, foo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "foo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "or",
    "fields" : [ {
      "type" : "selector",
      "dimension" : "dim2",
      "value" : "a"
    }, {
      "type" : "and",
      "fields" : [ {
        "type" : "selector",
        "dimension" : "dim2",
        "value" : null
      }, {
        "type" : "not",
        "field" : {
          "type" : "selector",
          "dimension" : "dim2",
          "value" : "a"
        }
      } ]
    } ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
[5]
=== run
=== options
sqlCompatibleNulls=true
=== results
[4]
==============================================================
Converted from testNullLongFilter()
=== case
Null long filter
=== SQL
SELECT COUNT(*)
FROM druid.numfoo
WHERE l1 IS NULL
=== options
sqlCompatibleNulls=false
vectorize=true
=== schema
EXPR$0 BIGINT
=== plan
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[0])
    LogicalFilter(condition=[IS NULL($12)])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "inline",
    "columnNames" : [ "EXPR$0" ],
    "columnTypes" : [ "LONG" ],
    "rows" : [ [ 0 ] ]
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "columns" : [ "EXPR$0" ],
  "legacy" : false,
  "granularity" : {
    "type" : "all"
  }
}
=== results
[0]
==============================================================
Converted from testNullLongFilter()
=== case
Null long filter
=== SQL copy
=== options
sqlCompatibleNulls=true
vectorize=true
=== schema copy
=== plan copy
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "selector",
    "dimension" : "l1"
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "context" : {
    "defaultTimeout" : 300000,
    "maxScatterGatherBytes" : 9223372036854775807,
    "sqlCurrentTimestamp" : "2000-01-01T00:00:00Z",
    "sqlQueryId" : "dummy"
  }
}
=== results
[3]
==============================================================
Converted from testNullDoubleFilter()
=== case
Null double filter
=== SQL
SELECT COUNT(*)
FROM druid.numfoo
WHERE d1 IS NULL
=== options
sqlCompatibleNulls=false
vectorize=true
=== schema
EXPR$0 BIGINT
=== plan
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[0])
    LogicalFilter(condition=[IS NULL($2)])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "inline",
    "columnNames" : [ "EXPR$0" ],
    "columnTypes" : [ "LONG" ],
    "rows" : [ [ 0 ] ]
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "columns" : [ "EXPR$0" ],
  "legacy" : false,
  "granularity" : {
    "type" : "all"
  }
}
=== results
[0]
==============================================================
Converted from testNullDoubleFilter()
=== case
Null double filter
=== SQL copy
=== options
sqlCompatibleNulls=true
vectorize=true
=== schema copy
=== plan copy
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "selector",
    "dimension" : "d1"
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "context" : {
    "defaultTimeout" : 300000,
    "maxScatterGatherBytes" : 9223372036854775807,
    "sqlCurrentTimestamp" : "2000-01-01T00:00:00Z",
    "sqlQueryId" : "dummy"
  }
}
=== results
[3]
==============================================================
Converted from testNullFloatFilter()
=== case
Null float filter
=== SQL
SELECT COUNT(*)
FROM druid.numfoo
WHERE f1 IS NULL
=== options
sqlCompatibleNulls=false
vectorize=true
=== schema
EXPR$0 BIGINT
=== plan
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[0])
    LogicalFilter(condition=[IS NULL($10)])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "inline",
    "columnNames" : [ "EXPR$0" ],
    "columnTypes" : [ "LONG" ],
    "rows" : [ [ 0 ] ]
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "resultFormat" : "compactedList",
  "columns" : [ "EXPR$0" ],
  "legacy" : false,
  "granularity" : {
    "type" : "all"
  }
}
=== results
[0]
==============================================================
Converted from testNullFloatFilter()
=== case
Null float filter
=== SQL copy
=== options
sqlCompatibleNulls=true
vectorize=true
=== schema copy
=== plan copy
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "selector",
    "dimension" : "f1"
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ],
  "context" : {
    "defaultTimeout" : 300000,
    "maxScatterGatherBytes" : 9223372036854775807,
    "sqlCurrentTimestamp" : "2000-01-01T00:00:00Z",
    "sqlQueryId" : "dummy"
  }
}
=== results
[3]
==============================================================
Converted from testNullDoubleTopN()
=== case
Null double top n
=== SQL
SELECT d1, COUNT(*)
FROM druid.numfoo
GROUP BY d1
ORDER BY d1 DESC
LIMIT 10
=== options
vectorize=true
=== schema
d1 DOUBLE
EXPR$1 BIGINT
=== plan
LogicalSort(sort0=[$0], dir0=[DESC], fetch=[10])
  LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
    LogicalProject(d1=[$2])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "topN",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "dimension" : {
    "type" : "default",
    "dimension" : "d1",
    "outputName" : "_d0",
    "outputType" : "DOUBLE"
  },
  "metric" : {
    "type" : "inverted",
    "metric" : {
      "type" : "dimension",
      "ordering" : {
        "type" : "numeric"
      }
    }
  },
  "threshold" : 10,
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
[1.7,1]
[1.0,1]
[0.0,4]
=== run
=== options
sqlCompatibleNulls=true
=== results
[null,3]
[1.7,1]
[1.0,1]
[0.0,1]
==============================================================
Converted from testNullFloatTopN()
=== case
Null float top n
=== SQL
SELECT f1, COUNT(*)
FROM druid.numfoo
GROUP BY f1
ORDER BY f1 DESC
LIMIT 10
=== options
vectorize=true
=== schema
f1 FLOAT
EXPR$1 BIGINT
=== plan
LogicalSort(sort0=[$0], dir0=[DESC], fetch=[10])
  LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
    LogicalProject(f1=[$10])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "topN",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "dimension" : {
    "type" : "default",
    "dimension" : "f1",
    "outputName" : "_d0",
    "outputType" : "FLOAT"
  },
  "metric" : {
    "type" : "inverted",
    "metric" : {
      "type" : "dimension",
      "ordering" : {
        "type" : "numeric"
      }
    }
  },
  "threshold" : 10,
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
[1.0,1]
[0.1,1]
[0.0,4]
=== run
=== options
sqlCompatibleNulls=true
=== results
[null,3]
[1.0,1]
[0.1,1]
[0.0,1]
==============================================================
Converted from testNullLongTopN()
=== case
Null long top n
=== SQL
SELECT l1, COUNT(*)
FROM druid.numfoo
GROUP BY l1
ORDER BY l1 DESC
LIMIT 10
=== options
vectorize=true
=== schema
l1 BIGINT
EXPR$1 BIGINT
=== plan
LogicalSort(sort0=[$0], dir0=[DESC], fetch=[10])
  LogicalAggregate(group=[{0}], EXPR$1=[COUNT()])
    LogicalProject(l1=[$12])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "topN",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "dimension" : {
    "type" : "default",
    "dimension" : "l1",
    "outputName" : "_d0",
    "outputType" : "LONG"
  },
  "metric" : {
    "type" : "inverted",
    "metric" : {
      "type" : "dimension",
      "ordering" : {
        "type" : "numeric"
      }
    }
  },
  "threshold" : 10,
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ]
}
=== run
=== options
sqlCompatibleNulls=false
=== results
[325323,1]
[7,1]
[0,4]
=== run
=== options
sqlCompatibleNulls=true
=== results
[null,3]
[325323,1]
[7,1]
[0,1]
==============================================================
Converted from testLongPredicateIsNull()
=== case
Long predicate is null
=== SQL
SELECT l1 is null
FROM druid.numfoo
=== options
sqlCompatibleNulls=false
vectorize=true
=== schema
EXPR$0 BOOLEAN
=== plan
LogicalProject(EXPR$0=[false])
  LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "0",
    "outputType" : "LONG"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "v0" ],
  "legacy" : false,
  "granularity" : {
    "type" : "all"
  }
}
=== results
[false]
[false]
[false]
[false]
[false]
[false]
==============================================================
Converted from testLongPredicateIsNull()
=== case
Long predicate is null
=== SQL copy
=== options
sqlCompatibleNulls=true
vectorize=true
=== schema copy
=== plan copy
=== native
{
  "queryType" : "scan",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "virtualColumns" : [ {
    "type" : "expression",
    "name" : "v0",
    "expression" : "isnull(\"l1\")",
    "outputType" : "LONG"
  } ],
  "resultFormat" : "compactedList",
  "columns" : [ "v0" ],
  "context" : {
    "defaultTimeout" : 300000,
    "maxScatterGatherBytes" : 9223372036854775807,
    "sqlCurrentTimestamp" : "2000-01-01T00:00:00Z",
    "sqlQueryId" : "dummy"
  },
  "granularity" : {
    "type" : "all"
  }
}
=== results
[false]
[false]
[false]
[true]
[true]
[true]
==============================================================
Converted from testLongPredicateFilterNulls()
=== case
Long predicate filter nulls
=== SQL
SELECT COUNT(*)
FROM druid.numfoo
WHERE l1 > 3
=== options
sqlCompatibleNulls=both
vectorize=true
=== schema
EXPR$0 BIGINT
=== plan
LogicalAggregate(group=[{}], EXPR$0=[COUNT()])
  LogicalProject($f0=[0])
    LogicalFilter(condition=[>($12, 3)])
      LogicalTableScan(table=[[druid, numfoo]])
=== native
{
  "queryType" : "timeseries",
  "dataSource" : {
    "type" : "table",
    "name" : "numfoo"
  },
  "intervals" : {
    "type" : "intervals",
    "intervals" : [ "-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z" ]
  },
  "filter" : {
    "type" : "bound",
    "dimension" : "l1",
    "lower" : "3",
    "lowerStrict" : true,
    "ordering" : {
      "type" : "numeric"
    }
  },
  "granularity" : {
    "type" : "all"
  },
  "aggregations" : [ {
    "type" : "count",
    "name" : "a0"
  } ]
}
=== results
[2]
