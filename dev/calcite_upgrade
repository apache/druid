#!/bin/bash

[ $# -ne 1 ] && echo -e "updates base parser sources.\n usage: $0 <new_calcite_version>" && exit 1


# Establishes a git friendly merge situation:
#
# Creates a commit which matches the original state of the calcite parser;
# To this point creates to alternates:
#   * one with local customizations
#   * another with all the upstream updates
# merges the two branches to obtain the upgrade state
#

set -e
set -x

BRANCH=`git name-rev --name-only HEAD`

REPO=.git/calcite-upgrade
rm -rf "$REPO"
git clone $PWD --reference $PWD --branch $BRANCH $REPO

cd "$REPO"
git checkout -b curr-changes

mvn generate-sources -pl sql -Pskip-static-checks
cp -r sql/target/calcite-base-parser/codegen/./  sql/src/main/codegen/./
git commit -m 'current reverse' -a
git revert --no-edit HEAD
# HEAD is now at the same as before; but parent are the base calcite changes

git branch base-changes curr-changes^
git checkout base-changes
git show|patch -p0 -R # undo temproarily to ensure maven runs

mvn generate-sources -pl sql -Dcalcite.version=$CALCITE_VERSION -Pskip-static-checks
cp -r sql/target/calcite-base-parser/codegen/./  sql/src/main/codegen/./

git commit --allow-empty -m base-changes -a
git checkout -b new-state
git merge --no-edit curr-changes

echo ok
cd -

git remote remove calcite-upgrade &>/dev/null || echo -n
git remote add -f calcite-upgrade "$REPO"


echo "merge branch calcite-upgrade/curr-changes if satisfied with those changes"

