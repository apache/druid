#!/usr/bin/env python3

# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

import sys
import os
import psutil
import pathlib
import multiprocessing
import argparse

QUICKSTART_ROOT_CONFIG_PATH = "conf/druid/single-server/quickstart"

MEM_GB_SUFFIX = "g"
MEM_MB_SUFFIX = "m"
SERVICE_SEPARATOR = ","

TASK_JAVA_OPTS_ARRAY = ["-server", "-Duser.timezone=UTC", "-Dfile.encoding=UTF-8", "-XX:+ExitOnOutOfMemoryError",
                        "-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager"]
TASK_JAVA_OPTS_PROPERTY = "-Ddruid.indexer.runner.javaOptsArray"
TASK_WORKER_CAPACITY_PROPERTY = "-Ddruid.worker.capacity"
TASK_COUNT = "task-count"
TASK_MEM_TYPE_LOW = "low"
TASK_MEM_TYPE_HIGH = "high"
TASK_MEM_MAP = {
    TASK_MEM_TYPE_LOW: ["-Xms256m", "-Xmx256m", "-XX:MaxDirectMemorySize=256g"],
    TASK_MEM_TYPE_HIGH: ["-Xms1g", "-Xmx1g", "-XX:MaxDirectMemorySize=1g"]
}

BROKER = "broker"
ROUTER = "router"
COORDINATOR = "coordinator-overlord"
HISTORICAL = "historical"
MIDDLE_MANAGER = "middleManager"
TASKS = "tasks"

DEFAULT_SERVICES = [
    BROKER,
    ROUTER,
    COORDINATOR,
    HISTORICAL,
    MIDDLE_MANAGER
]

SERVICE_MEMORY_RATIO = {
    MIDDLE_MANAGER: 1,
    ROUTER: 2,
    COORDINATOR: 30,
    BROKER: 46,
    HISTORICAL: 80,
    TASKS: 30
}

MINIMUM_MEMORY_MB = {
    MIDDLE_MANAGER: 64,
    ROUTER: 128,
    TASKS: 1024,
    BROKER: 900,
    COORDINATOR: 256,
    HISTORICAL: 900
}

HEAP_TO_TOTAL_MEM_RATIO = {
    MIDDLE_MANAGER: 1,
    ROUTER: 1,
    COORDINATOR: 1,
    BROKER: 0.60,
    HISTORICAL: 0.40,
    TASKS: 0.50
}

LOGGING_ENABLED = False


def print_if_verbose(message):
    if LOGGING_ENABLED:
        print(message)


def configure_parser():
    parser = argparse.ArgumentParser(
        prog='Druid quickstart',
        formatter_class=argparse.RawTextHelpFormatter,
        epilog=
        """
sample usage:
    start-druid
            Start up all the services (including zk).
    start-druid -m=100g
            Start up all the services (including zk)
            using a total memory of 100GB.
    start-druid -m=100g --compute
            Compute memory distribution and validate arguments.
    start-druid -m=100g -s=broker,router
            Starts a broker and a router, using a total memory of 100GB.
    start-druid -m=100g --s=broker,router \\
    -c=conf/druid/single-server/custom
            Starts a broker and a router, using a total memory of 100GB.
            Reads configs for each service (jvm.config, runtime.properties)
            from respective folders inside the given root config path.
    start-druid -s=broker,router \\
    -c=conf/druid/single-server/custom
            Starts a broker and a router service, reading service configs
            from the given root directory. Calculates memory requirements for
            each service, if required, using upto 80% of the total system memory.
    start-druid -m=100g \\
    -s=broker,router \\
    -c=conf/druid/single-server/custom \\
    --zk
            Starts broker, router and zookeeper.
            zookeeper config is read from conf/zk.
"""
    )
    parser.add_argument('--memory', '-m', type=str, required=False,
                        help='Total memory for all processes (services and tasks, if any). \n'
                             'This parameter is ignored if each service already has a jvm.config \n'
                             'in the given conf directory. e.g. 500m, 4g, 6g\n')
    parser.add_argument('--services', '-s', type=str, required=False,
                        help='List of services to be started, subset of \n'
                             '{broker, router, middleManager, historical, coordinator-overlord}. \n'
                             'If the argument is not given, all services \n'
                             'and zookeeper is started. e.g. -sl=broker,historical')
    parser.add_argument('--config', '-c', type=str, required=False,
                        help='Relative path to the directory containing common and service \n'
                             'specific properties to be overridden. \n'
                             'This directory must contain \'_common\' directory with \n'
                             '\'common.jvm.config\' & \'common.runtime.properties\' files. \n'
                             'If this argument is not given, config from \n'
                             'conf/druid/single-server/quickstart directory is used.\n')
    parser.add_argument('--compute', action='store_true',
                        help='Does not start Druid, only displays the memory allocated \n'
                             'to each service if started with the given total memory.\n')
    parser.add_argument('--zk', '-zk', action='store_true',
                        help='Specification to run zookeeper, \n'
                             'zk config is picked up from conf/zk.')
    parser.add_argument('--verbose', action='store_true', help='Log details')

    parser.set_defaults(zk=False)
    parser.set_defaults(compute=False)
    parser.set_defaults(verbose=False)

    return parser


def parse_arguments(args):
    service_list = []
    config = ""
    total_memory = ""
    compute = False
    zk = False

    if args.compute:
        compute = True
    if args.zk:
        zk = True
    if args.config is not None:
        config = pathlib.Path(os.path.join(os.getcwd(), args.config)).resolve()
        if os.path.exists(config) is False:
            raise ValueError(f'config {config} not found')
    if args.memory is not None:
        total_memory = args.memory
    if args.services is not None:
        services = args.services.split(SERVICE_SEPARATOR)

        for service in services:
            if service not in DEFAULT_SERVICES:
                raise ValueError(f'Invalid service name {service}, should be one of {DEFAULT_SERVICES}')

            if service in service_list:
                raise ValueError(f'{service} is specified multiple times')

            service_list.append(service)

    if len(service_list) == 0:
        # start all services
        service_list = DEFAULT_SERVICES
        zk = True

    return config, total_memory, service_list, zk, compute


def print_startup_config(service_list, config, zk):
    print_if_verbose(f'starting {service_list}')
    print_if_verbose(f'reading config from {config}')
    if zk:
        zk_config = pathlib.Path(f'{os.getcwd()}/../conf/zk').resolve()
        print_if_verbose(f'starting zk, reading default config from {zk_config}')
    print_if_verbose('\n')


def should_compute_memory(config, total_memory, service_list):
    # if jvm file is present for any of the services
    # it should be present for all services and memory should not be specified
    # if memory is given, jvm file shouldn't be present for any service
    jvm_config_count = 0
    for service in service_list:
        if pathlib.Path(f'{config}/{service}/jvm.config').is_file():
            jvm_config_count += 1
        elif jvm_config_count > 0:
            raise ValueError(
                f'jvm.config file is missing for service {service}, jvm.config should be specified for all the '
                f'services or none')

    if jvm_config_count > 0 and (jvm_config_count != len(service_list) or total_memory != ""):
        if jvm_config_count != len(service_list):
            raise ValueError("jvm.config file should be present for all services or none")
        if total_memory != "":
            raise ValueError("If jvm.config is given for services, memory argument shouldn't be specified")

    return jvm_config_count == 0


def compute_system_memory():
    system_memory = psutil.virtual_memory().total  # mem in bytes
    memory_for_druid = int(system_memory / (1024 * 1024))
    return memory_for_druid


def convert_total_memory_string(memory):
    try:
        if memory == "":
            computed_memory = compute_system_memory()
            return computed_memory
        elif memory.endswith(MEM_MB_SUFFIX):
            return int(memory[:-1])
        elif memory.endswith(MEM_GB_SUFFIX):
            return 1024 * int(memory[:-1])
        else:
            raise ValueError('Incorrect format for memory argument, expected format is <integer_value><m/g>')
    except Exception:
        raise ValueError('Incorrect format for memory argument, expected format is <integer_value><m/g>')


def check_memory_constraint(total_memory, service_list):
    # 80% of total memory >= sum of lower bound service memory should be
    lower_bound_memory = 0

    for service in service_list:
        lower_bound_memory += MINIMUM_MEMORY_MB.get(service)

    required_memory = int(lower_bound_memory / 0.8)

    if total_memory < required_memory:
        raise ValueError(f'Minimum memory required for starting services is {required_memory}m')

    if total_memory >= 2 * lower_bound_memory:
        return int(total_memory / 2)
    else:
        return lower_bound_memory


def build_mm_task_java_opts_array(memory_type):
    task_memory = f'{TASK_JAVA_OPTS_PROPERTY}=['

    mem_array = TASK_MEM_MAP.get(memory_type)

    java_opts_list = TASK_JAVA_OPTS_ARRAY + mem_array

    for item in java_opts_list:
        task_memory += f'\"{item}\";'

    task_memory = task_memory[:-1]
    task_memory += ']'
    return task_memory


def compute_tasks_memory(allocated_memory):
    if allocated_memory >= 2048:
        task_count = int(allocated_memory / 2048)
        memory_type = TASK_MEM_TYPE_HIGH
        task_memory_mb = 2048
    else:
        task_count = int(allocated_memory / 512)
        memory_type = TASK_MEM_TYPE_LOW
        task_memory_mb = 512
    task_count = min(task_count, multiprocessing.cpu_count())

    return memory_type, task_count, task_memory_mb


def build_memory_config(service, allocated_memory):
    if service == TASKS:
        memory_type, task_count, task_memory = compute_tasks_memory(allocated_memory)
        java_opts_array = build_mm_task_java_opts_array(memory_type)
        return [f'{TASK_WORKER_CAPACITY_PROPERTY}={task_count}', java_opts_array], task_memory * task_count
    else:
        heap_memory = HEAP_TO_TOTAL_MEM_RATIO.get(service) * allocated_memory
        direct_memory = int(allocated_memory - heap_memory)
        heap_memory = int(heap_memory)

        if direct_memory == 0:
            return f'-Xms{heap_memory}m -Xmx{heap_memory}m', allocated_memory

        return f'-Xms{heap_memory}m -Xmx{heap_memory}m -XX:MaxDirectMemorySize={direct_memory}m', allocated_memory


def distribute_memory_over_services(services, total_memory):
    service_memory_config = {}

    memory_weight_sum = 0

    service_list = services.copy()
    if MIDDLE_MANAGER in services:
        service_list.append(TASKS)

    for service in service_list:
        memory_weight_sum += SERVICE_MEMORY_RATIO.get(service)

    multiplier = total_memory / memory_weight_sum

    lower_bound_memory_allocation = 0
    allocated_services = set()

    for service in service_list:
        allocated_memory = SERVICE_MEMORY_RATIO.get(service) * multiplier
        if service in MINIMUM_MEMORY_MB and allocated_memory < MINIMUM_MEMORY_MB.get(service):
            allocated_memory = MINIMUM_MEMORY_MB.get(service)
            service_memory_config[service], allocated_memory = build_memory_config(service, allocated_memory)
            lower_bound_memory_allocation += allocated_memory
            allocated_services.add(service)

    if lower_bound_memory_allocation > 0:
        # compute the multiplier again for remaining services
        memory_weight_sum = 0
        for service in service_list:
            if service in allocated_services:
                continue
            memory_weight_sum += SERVICE_MEMORY_RATIO.get(service)
        multiplier = (total_memory - lower_bound_memory_allocation) / memory_weight_sum

    for service in service_list:
        if service in allocated_services:
            continue
        allocated_memory = SERVICE_MEMORY_RATIO.get(service) * multiplier
        if service in MINIMUM_MEMORY_MB and allocated_memory < MINIMUM_MEMORY_MB.get(service):
            allocated_memory = MINIMUM_MEMORY_MB.get(service)

        service_memory_config[service], allocated_memory = build_memory_config(service, allocated_memory)

    print_if_verbose(f'\nMemory distribution for services:')
    for key, value in service_memory_config.items():
        print_if_verbose(f'{key}, memory_config: {value}')
    print_if_verbose('\n')

    return service_memory_config


def build_supervise_script_arguments(service_list, service_memory_config, config, zk):
    args = []
    commands = []
    args.append('supervise')
    args.append('-a')

    commands.append(":verify bin/verify-java")
    commands.append(":verify bin/verify-default-ports")
    commands.append(":notify bin/greet")
    commands.append(":kill-timeout 10")

    if zk:
        commands.append("!p10 zk bin/run-zk conf")

    for service in service_list:
        jvm_args = service_memory_config.get(service)

        prefix = ''
        if service == MIDDLE_MANAGER:
            prefix = '!p90 '

        if jvm_args is None:
            commands.append(f'{prefix}{service} bin/run-druid {service} {config}')
        else:
            if service == MIDDLE_MANAGER:
                task_config = service_memory_config.get(TASKS)
                task_count = task_config[0]
                task_memory = task_config[1]
                commands.append(
                    f'{prefix}{service} bin/run-druid {service} {config} \'{jvm_args}\' \'{task_count} {task_memory}\'')
            else:
                commands.append(f'{prefix}{service} bin/run-druid {service} {config} \'{jvm_args}\'')

    print_if_verbose('Supervise script args:')
    for item in commands:
        print_if_verbose(item)

    print_if_verbose('\n')

    args.append(",".join(commands))
    return args


def main():
    parser = configure_parser()
    args = parser.parse_args()

    global LOGGING_ENABLED
    LOGGING_ENABLED = args.verbose or args.compute

    config, total_memory, service_list, zk, compute = parse_arguments(args)

    # change directory to bin
    os.chdir(os.path.dirname(sys.argv[0]))

    if config == "":
        config = pathlib.Path(f'{os.getcwd()}/../{QUICKSTART_ROOT_CONFIG_PATH}').resolve()

    print_startup_config(service_list, config, zk)

    service_memory_config = {}

    if should_compute_memory(config, total_memory, service_list):
        memory_in_mega_bytes = convert_total_memory_string(total_memory)
        print_if_verbose(f'total memory is {memory_in_mega_bytes}m')
        memory_to_be_used = check_memory_constraint(memory_in_mega_bytes, service_list)
        print_if_verbose(f'memory used for services & tasks {memory_to_be_used}m')
        service_memory_config = distribute_memory_over_services(service_list, memory_to_be_used)
    else:
        print_if_verbose('not computing memory distribution, reading memory specification from service jvm.config\n')

    script_arguments = build_supervise_script_arguments(service_list, service_memory_config, config, zk)

    if compute:
        return

    os.execv('./supervise', script_arguments)


try:
    main()
except (KeyboardInterrupt, ValueError) as error:
    print(error)
    sys.exit(1)
