// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`LookupEditDialog matches snapshot 1`] = `
<Blueprint4.Dialog
  canEscapeKeyClose={false}
  canOutsideClickClose={true}
  className="lookup-edit-dialog"
  isOpen={true}
  onClose={[Function]}
  title="Add lookup"
>
  <div
    className="content"
  >
    <Blueprint4.FormGroup
      label="Name"
    >
      <Blueprint4.InputGroup
        disabled={false}
        intent="none"
        onChange={[Function]}
        placeholder="Enter the lookup name"
        value="test"
      />
    </Blueprint4.FormGroup>
    <Blueprint4.FormGroup
      label="Tier"
    >
      <HTMLSelect
        onChange={[Function]}
        value="test"
      >
        <option
          value="__default"
        >
          __default
        </option>
        <option
          value="alt-tier"
        >
          alt-tier
        </option>
      </HTMLSelect>
    </Blueprint4.FormGroup>
    <Blueprint4.FormGroup
      label="Version"
    >
      <Blueprint4.InputGroup
        onChange={[Function]}
        placeholder="Enter the lookup version"
        rightElement={
          <Blueprint4.Button
            minimal={true}
            onClick={[Function]}
            text="Set to current ISO time"
          />
        }
        value="test"
      />
    </Blueprint4.FormGroup>
    <Memo(FormJsonSelector)
      onChange={[Function]}
      tab="form"
    />
    <AutoForm
      fields={
        Array [
          Object {
            "adjustment": [Function],
            "name": "type",
            "required": true,
            "suggestions": Array [
              "map",
              "cachedNamespace",
              "kafka",
            ],
            "type": "string",
          },
          Object {
            "defined": [Function],
            "height": "60vh",
            "issueWithValue": [Function],
            "name": "map",
            "required": true,
            "type": "json",
          },
          Object {
            "defined": [Function],
            "label": "Extraction type",
            "name": "extractionNamespace.type",
            "placeholder": "uri",
            "required": true,
            "suggestions": Array [
              "uri",
              "jdbc",
            ],
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": <p>
              A URI which specifies a directory (or other searchable resource) in which to search for files specified as a 
              <Unknown>
                file
              </Unknown>
              , 
              <Unknown>
                hdfs
              </Unknown>
              , 
              <Unknown>
                s3
              </Unknown>
              , or
               
              <Unknown>
                gs
              </Unknown>
               path prefix.
            </p>,
            "issueWithValue": [Function],
            "label": "URI prefix",
            "name": "extractionNamespace.uriPrefix",
            "placeholder": "s3://bucket/some/key/prefix/",
            "required": [Function],
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": <React.Fragment>
              <p>
                URI for the file of interest, specified as a 
                <Unknown>
                  file
                </Unknown>
                , 
                <Unknown>
                  hdfs
                </Unknown>
                ,
                 
                <Unknown>
                  s3
                </Unknown>
                , or 
                <Unknown>
                  gs
                </Unknown>
                 path
              </p>
              <p>
                The URI prefix option is strictly better than URI and should be used instead
              </p>
            </React.Fragment>,
            "issueWithValue": [Function],
            "label": "URI (deprecated)",
            "name": "extractionNamespace.uri",
            "placeholder": "s3://bucket/some/key/prefix/lookups-01.gz",
            "required": [Function],
            "type": "string",
          },
          Object {
            "defaultValue": ".*",
            "defined": [Function],
            "info": "Optional regex for matching the file name under uriPrefix.",
            "label": "File regex",
            "name": "extractionNamespace.fileRegex",
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": <React.Fragment>
              <p>
                The format of the data in the lookup files.
              </p>
              <p>
                The 
                <Unknown>
                  simpleJson
                </Unknown>
                 lookupParseSpec does not take any parameters. It is simply a line delimited JSON file where the field is the key, and the field's value is the value.
              </p>
            </React.Fragment>,
            "label": "Parse format",
            "name": "extractionNamespace.namespaceParseSpec.format",
            "required": true,
            "suggestions": Array [
              "csv",
              "tsv",
              "simpleJson",
              "customJson",
            ],
            "type": "string",
          },
          Object {
            "defaultValue": "	",
            "defined": [Function],
            "name": "extractionNamespace.namespaceParseSpec.delimiter",
            "suggestions": Array [
              "	",
              ";",
              "|",
              "#",
            ],
            "type": "string",
          },
          Object {
            "defaultValue": 0,
            "defined": [Function],
            "info": "Number of header rows to be skipped.",
            "name": "extractionNamespace.namespaceParseSpec.skipHeaderRows",
            "type": "number",
          },
          Object {
            "defaultValue": false,
            "defined": [Function],
            "info": "A flag to indicate that column information can be extracted from the input files' header row",
            "name": "extractionNamespace.namespaceParseSpec.hasHeaderRow",
            "type": "boolean",
          },
          Object {
            "defined": [Function],
            "info": "The list of columns in the csv file",
            "name": "extractionNamespace.namespaceParseSpec.columns",
            "placeholder": "key, value",
            "required": [Function],
            "type": "string-array",
          },
          Object {
            "defined": [Function],
            "info": "The name of the column containing the key",
            "name": "extractionNamespace.namespaceParseSpec.keyColumn",
            "placeholder": "(optional - defaults to the first column)",
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": "The name of the column containing the value",
            "name": "extractionNamespace.namespaceParseSpec.valueColumn",
            "placeholder": "(optional - defaults to the second column)",
            "type": "string",
          },
          Object {
            "defined": [Function],
            "name": "extractionNamespace.namespaceParseSpec.keyFieldName",
            "placeholder": "key",
            "required": true,
            "type": "string",
          },
          Object {
            "defined": [Function],
            "name": "extractionNamespace.namespaceParseSpec.valueFieldName",
            "placeholder": "value",
            "required": true,
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": "Defines the connectURI for connecting to the database",
            "issueWithValue": [Function],
            "label": "Connect URI",
            "name": "extractionNamespace.connectorConfig.connectURI",
            "required": true,
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": "Defines the user to be used by the connector config",
            "name": "extractionNamespace.connectorConfig.user",
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": "Defines the password to be used by the connector config",
            "name": "extractionNamespace.connectorConfig.password",
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": <React.Fragment>
              <p>
                The table which contains the key value pairs. This will become the table value in the SQL query:
              </p>
              <p>
                SELECT keyColumn, valueColumn, tsColumn? FROM 
                <strong>
                  table
                </strong>
                 WHERE filter
              </p>
            </React.Fragment>,
            "name": "extractionNamespace.table",
            "placeholder": "lookup_table",
            "required": true,
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": <React.Fragment>
              <p>
                The column in the table which contains the keys. This will become the keyColumn value in the SQL query:
              </p>
              <p>
                SELECT 
                <strong>
                  keyColumn
                </strong>
                , valueColumn, tsColumn? FROM table WHERE filter
              </p>
            </React.Fragment>,
            "name": "extractionNamespace.keyColumn",
            "placeholder": "key_column",
            "required": true,
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": <React.Fragment>
              <p>
                The column in table which contains the values. This will become the valueColumn value in the SQL query:
              </p>
              <p>
                SELECT keyColumn, 
                <strong>
                  valueColumn
                </strong>
                , tsColumn? FROM table WHERE filter
              </p>
            </React.Fragment>,
            "name": "extractionNamespace.valueColumn",
            "placeholder": "value_column",
            "required": true,
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": <React.Fragment>
              <p>
                The column in table which contains when the key was updated. This will become the Value in the SQL query:
              </p>
              <p>
                SELECT keyColumn, valueColumn, 
                <strong>
                  tsColumn
                </strong>
                ? FROM table WHERE filter
              </p>
            </React.Fragment>,
            "label": "Timestamp column",
            "name": "extractionNamespace.tsColumn",
            "placeholder": "timestamp_column (optional)",
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": <React.Fragment>
              <p>
                The filter to be used when selecting lookups, this is used to create a where clause on lookup population. This will become the expression filter in the SQL query:
              </p>
              <p>
                SELECT keyColumn, valueColumn, tsColumn? FROM table WHERE 
                <strong>
                  filter
                </strong>
              </p>
            </React.Fragment>,
            "name": "extractionNamespace.filter",
            "placeholder": "for_lookup = 1 (optional)",
            "type": "string",
          },
          Object {
            "defined": [Function],
            "info": "Period between polling for updates",
            "name": "extractionNamespace.pollPeriod",
            "required": true,
            "suggestions": Array [
              "PT1M",
              "PT10M",
              "PT30M",
              "PT1H",
              "PT6H",
              "P1D",
            ],
            "type": "duration",
          },
          Object {
            "defaultValue": 0,
            "defined": [Function],
            "info": "How much jitter to add (in seconds) up to maximum as a delay (actual value will be used as random from 0 to jitterSeconds), used to distribute db load more evenly. Default is 0.",
            "name": "extractionNamespace.jitterSeconds",
            "required": false,
            "suggestions": Array [],
            "type": "number",
          },
          Object {
            "defaultValue": 60,
            "defined": [Function],
            "info": "How much time (in seconds) it can take to query and populate lookup values. It will be helpful in lookup updates. On lookup update, it will wait maximum of \`loadTimeoutSeconds\` for new lookup to come up and continue serving from old lookup until new lookup successfully loads. Default is 60 Sec.",
            "name": "extractionNamespace.loadTimeoutSeconds",
            "required": false,
            "suggestions": Array [],
            "type": "number",
          },
          Object {
            "defaultValue": 10,
            "defined": [Function],
            "info": "The maximum percentage of heap size that the lookup should consume. If the lookup grows beyond this size, warning messages will be logged in the respective service logs. Default is 10 % of jvm size.",
            "name": "extractionNamespace.maxHeapPercentage",
            "required": false,
            "suggestions": Array [],
            "type": "number",
          },
          Object {
            "defaultValue": 0,
            "defined": [Function],
            "info": "How long to wait (in ms) for the first run of the cache to populate. 0 indicates to not wait",
            "name": "firstCacheTimeout",
            "type": "number",
          },
          Object {
            "defaultValue": false,
            "defined": [Function],
            "info": "If the underlying map is injective (keys and values are unique) then optimizations can occur internally by setting this to true",
            "name": "injective",
            "type": "boolean",
          },
          Object {
            "defined": [Function],
            "info": "The Kafka topic to read the data from",
            "name": "kafkaTopic",
            "required": true,
            "type": "string",
          },
          Object {
            "defined": [Function],
            "height": "100px",
            "issueWithValue": [Function],
            "name": "kafkaProperties",
            "required": true,
            "type": "json",
          },
          Object {
            "defaultValue": 0,
            "defined": [Function],
            "info": "How long to wait for an initial connection",
            "name": "connectTimeout",
            "type": "number",
          },
          Object {
            "defaultValue": false,
            "defined": [Function],
            "info": "If the underlying map is one-to-one (keys and values are unique) then optimizations can occur internally by setting this to true",
            "name": "isOneToOne",
            "type": "boolean",
          },
        ]
      }
      model={
        Object {
          "map": Object {
            "a": 1,
          },
          "type": "map",
        }
      }
      onChange={[Function]}
    />
  </div>
  <div
    className="bp4-dialog-footer"
  >
    <div
      className="bp4-dialog-footer-actions"
    >
      <Blueprint4.Button
        onClick={[Function]}
        text="Close"
      />
      <Blueprint4.Button
        disabled={false}
        intent="primary"
        onClick={[Function]}
        text="Submit"
      />
    </div>
  </div>
</Blueprint4.Dialog>
`;
